// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RMODELMETADATA_FLAT_H_
#define FLATBUFFERS_GENERATED_RMODELMETADATA_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "AssetName_generated.h"
#include "Mesh_generated.h"
#include "RAnimationMetaData_generated.h"

namespace flat {

struct SkeletonMetaData;
struct SkeletonMetaDataBuilder;

struct BoneMetaData;
struct BoneMetaDataBuilder;

struct Bounds;

struct MeshInfo;
struct MeshInfoBuilder;

struct RModelMetaData;
struct RModelMetaDataBuilder;

enum MeshCompressionMode {
  MeshCompressionMode_NONE = 0,
  MeshCompressionMode_LZ4 = 1,
  MeshCompressionMode_MIN = MeshCompressionMode_NONE,
  MeshCompressionMode_MAX = MeshCompressionMode_LZ4
};

inline const MeshCompressionMode (&EnumValuesMeshCompressionMode())[2] {
  static const MeshCompressionMode values[] = {
    MeshCompressionMode_NONE,
    MeshCompressionMode_LZ4
  };
  return values;
}

inline const char * const *EnumNamesMeshCompressionMode() {
  static const char * const names[3] = {
    "NONE",
    "LZ4",
    nullptr
  };
  return names;
}

inline const char *EnumNameMeshCompressionMode(MeshCompressionMode e) {
  if (flatbuffers::IsOutRange(e, MeshCompressionMode_NONE, MeshCompressionMode_LZ4)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMeshCompressionMode()[index];
}

enum VertexFormat {
  VertexFormat_UNKNOWN = 0,
  VertexFormat_P32N32UV32T32 = 1,
  VertexFormat_MIN = VertexFormat_UNKNOWN,
  VertexFormat_MAX = VertexFormat_P32N32UV32T32
};

inline const VertexFormat (&EnumValuesVertexFormat())[2] {
  static const VertexFormat values[] = {
    VertexFormat_UNKNOWN,
    VertexFormat_P32N32UV32T32
  };
  return values;
}

inline const char * const *EnumNamesVertexFormat() {
  static const char * const names[3] = {
    "UNKNOWN",
    "P32N32UV32T32",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexFormat(VertexFormat e) {
  if (flatbuffers::IsOutRange(e, VertexFormat_UNKNOWN, VertexFormat_P32N32UV32T32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexFormat()[index];
}

enum VertexOrdering {
  VertexOrdering_INTERLEAVED = 0,
  VertexOrdering_INDIVIDUAL_COMPONENTS = 1,
  VertexOrdering_MIN = VertexOrdering_INTERLEAVED,
  VertexOrdering_MAX = VertexOrdering_INDIVIDUAL_COMPONENTS
};

inline const VertexOrdering (&EnumValuesVertexOrdering())[2] {
  static const VertexOrdering values[] = {
    VertexOrdering_INTERLEAVED,
    VertexOrdering_INDIVIDUAL_COMPONENTS
  };
  return values;
}

inline const char * const *EnumNamesVertexOrdering() {
  static const char * const names[3] = {
    "INTERLEAVED",
    "INDIVIDUAL_COMPONENTS",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexOrdering(VertexOrdering e) {
  if (flatbuffers::IsOutRange(e, VertexOrdering_INTERLEAVED, VertexOrdering_INDIVIDUAL_COMPONENTS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexOrdering()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Bounds FLATBUFFERS_FINAL_CLASS {
 private:
  flat::Vertex3 origin_;
  float radius_;
  flat::Vertex3 extents_;

 public:
  Bounds() {
    memset(static_cast<void *>(this), 0, sizeof(Bounds));
  }
  Bounds(const flat::Vertex3 &_origin, float _radius, const flat::Vertex3 &_extents)
      : origin_(_origin),
        radius_(flatbuffers::EndianScalar(_radius)),
        extents_(_extents) {
  }
  const flat::Vertex3 &origin() const {
    return origin_;
  }
  flat::Vertex3 &mutable_origin() {
    return origin_;
  }
  float radius() const {
    return flatbuffers::EndianScalar(radius_);
  }
  void mutate_radius(float _radius) {
    flatbuffers::WriteScalar(&radius_, _radius);
  }
  const flat::Vertex3 &extents() const {
    return extents_;
  }
  flat::Vertex3 &mutable_extents() {
    return extents_;
  }
};
FLATBUFFERS_STRUCT_END(Bounds, 28);

struct SkeletonMetaData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkeletonMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMJOINTS = 4,
    VT_NUMPARENTS = 6,
    VT_NUMRESTPOSETRANSFORMS = 8,
    VT_NUMBINDPOSETRANSFORMS = 10
  };
  uint32_t numJoints() const {
    return GetField<uint32_t>(VT_NUMJOINTS, 0);
  }
  bool mutate_numJoints(uint32_t _numJoints) {
    return SetField<uint32_t>(VT_NUMJOINTS, _numJoints, 0);
  }
  uint32_t numParents() const {
    return GetField<uint32_t>(VT_NUMPARENTS, 0);
  }
  bool mutate_numParents(uint32_t _numParents) {
    return SetField<uint32_t>(VT_NUMPARENTS, _numParents, 0);
  }
  uint32_t numRestPoseTransforms() const {
    return GetField<uint32_t>(VT_NUMRESTPOSETRANSFORMS, 0);
  }
  bool mutate_numRestPoseTransforms(uint32_t _numRestPoseTransforms) {
    return SetField<uint32_t>(VT_NUMRESTPOSETRANSFORMS, _numRestPoseTransforms, 0);
  }
  uint32_t numBindPoseTransforms() const {
    return GetField<uint32_t>(VT_NUMBINDPOSETRANSFORMS, 0);
  }
  bool mutate_numBindPoseTransforms(uint32_t _numBindPoseTransforms) {
    return SetField<uint32_t>(VT_NUMBINDPOSETRANSFORMS, _numBindPoseTransforms, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMJOINTS) &&
           VerifyField<uint32_t>(verifier, VT_NUMPARENTS) &&
           VerifyField<uint32_t>(verifier, VT_NUMRESTPOSETRANSFORMS) &&
           VerifyField<uint32_t>(verifier, VT_NUMBINDPOSETRANSFORMS) &&
           verifier.EndTable();
  }
};

struct SkeletonMetaDataBuilder {
  typedef SkeletonMetaData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numJoints(uint32_t numJoints) {
    fbb_.AddElement<uint32_t>(SkeletonMetaData::VT_NUMJOINTS, numJoints, 0);
  }
  void add_numParents(uint32_t numParents) {
    fbb_.AddElement<uint32_t>(SkeletonMetaData::VT_NUMPARENTS, numParents, 0);
  }
  void add_numRestPoseTransforms(uint32_t numRestPoseTransforms) {
    fbb_.AddElement<uint32_t>(SkeletonMetaData::VT_NUMRESTPOSETRANSFORMS, numRestPoseTransforms, 0);
  }
  void add_numBindPoseTransforms(uint32_t numBindPoseTransforms) {
    fbb_.AddElement<uint32_t>(SkeletonMetaData::VT_NUMBINDPOSETRANSFORMS, numBindPoseTransforms, 0);
  }
  explicit SkeletonMetaDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkeletonMetaDataBuilder &operator=(const SkeletonMetaDataBuilder &);
  flatbuffers::Offset<SkeletonMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkeletonMetaData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkeletonMetaData> CreateSkeletonMetaData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t numJoints = 0,
    uint32_t numParents = 0,
    uint32_t numRestPoseTransforms = 0,
    uint32_t numBindPoseTransforms = 0) {
  SkeletonMetaDataBuilder builder_(_fbb);
  builder_.add_numBindPoseTransforms(numBindPoseTransforms);
  builder_.add_numRestPoseTransforms(numRestPoseTransforms);
  builder_.add_numParents(numParents);
  builder_.add_numJoints(numJoints);
  return builder_.Finish();
}

struct BoneMetaData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoneMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBONEDATA = 4,
    VT_NUMBONEINFO = 6
  };
  uint32_t numBoneData() const {
    return GetField<uint32_t>(VT_NUMBONEDATA, 0);
  }
  bool mutate_numBoneData(uint32_t _numBoneData) {
    return SetField<uint32_t>(VT_NUMBONEDATA, _numBoneData, 0);
  }
  uint32_t numBoneInfo() const {
    return GetField<uint32_t>(VT_NUMBONEINFO, 0);
  }
  bool mutate_numBoneInfo(uint32_t _numBoneInfo) {
    return SetField<uint32_t>(VT_NUMBONEINFO, _numBoneInfo, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMBONEDATA) &&
           VerifyField<uint32_t>(verifier, VT_NUMBONEINFO) &&
           verifier.EndTable();
  }
};

struct BoneMetaDataBuilder {
  typedef BoneMetaData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numBoneData(uint32_t numBoneData) {
    fbb_.AddElement<uint32_t>(BoneMetaData::VT_NUMBONEDATA, numBoneData, 0);
  }
  void add_numBoneInfo(uint32_t numBoneInfo) {
    fbb_.AddElement<uint32_t>(BoneMetaData::VT_NUMBONEINFO, numBoneInfo, 0);
  }
  explicit BoneMetaDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoneMetaDataBuilder &operator=(const BoneMetaDataBuilder &);
  flatbuffers::Offset<BoneMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoneMetaData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoneMetaData> CreateBoneMetaData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t numBoneData = 0,
    uint32_t numBoneInfo = 0) {
  BoneMetaDataBuilder builder_(_fbb);
  builder_.add_numBoneInfo(numBoneInfo);
  builder_.add_numBoneData(numBoneData);
  return builder_.Finish();
}

struct MeshInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHNAME = 4,
    VT_VERTEXORDERING = 6,
    VT_VERTEXFORMAT = 8,
    VT_VERTEXBUFFERSIZE = 10,
    VT_INDEXBUFFERSIZE = 12,
    VT_MESHBOUNDS = 14,
    VT_SIZEOFANINDEX = 16,
    VT_COMPRESSIONMODE = 18,
    VT_COMPRESSEDSIZE = 20,
    VT_ORIGINALPATH = 22
  };
  uint64_t meshName() const {
    return GetField<uint64_t>(VT_MESHNAME, 0);
  }
  bool mutate_meshName(uint64_t _meshName) {
    return SetField<uint64_t>(VT_MESHNAME, _meshName, 0);
  }
  flat::VertexOrdering vertexOrdering() const {
    return static_cast<flat::VertexOrdering>(GetField<uint8_t>(VT_VERTEXORDERING, 0));
  }
  bool mutate_vertexOrdering(flat::VertexOrdering _vertexOrdering) {
    return SetField<uint8_t>(VT_VERTEXORDERING, static_cast<uint8_t>(_vertexOrdering), 0);
  }
  flat::VertexFormat vertexFormat() const {
    return static_cast<flat::VertexFormat>(GetField<uint8_t>(VT_VERTEXFORMAT, 0));
  }
  bool mutate_vertexFormat(flat::VertexFormat _vertexFormat) {
    return SetField<uint8_t>(VT_VERTEXFORMAT, static_cast<uint8_t>(_vertexFormat), 0);
  }
  uint64_t vertexBufferSize() const {
    return GetField<uint64_t>(VT_VERTEXBUFFERSIZE, 0);
  }
  bool mutate_vertexBufferSize(uint64_t _vertexBufferSize) {
    return SetField<uint64_t>(VT_VERTEXBUFFERSIZE, _vertexBufferSize, 0);
  }
  uint64_t indexBufferSize() const {
    return GetField<uint64_t>(VT_INDEXBUFFERSIZE, 0);
  }
  bool mutate_indexBufferSize(uint64_t _indexBufferSize) {
    return SetField<uint64_t>(VT_INDEXBUFFERSIZE, _indexBufferSize, 0);
  }
  const flat::Bounds *meshBounds() const {
    return GetStruct<const flat::Bounds *>(VT_MESHBOUNDS);
  }
  flat::Bounds *mutable_meshBounds() {
    return GetStruct<flat::Bounds *>(VT_MESHBOUNDS);
  }
  uint8_t sizeOfAnIndex() const {
    return GetField<uint8_t>(VT_SIZEOFANINDEX, 0);
  }
  bool mutate_sizeOfAnIndex(uint8_t _sizeOfAnIndex) {
    return SetField<uint8_t>(VT_SIZEOFANINDEX, _sizeOfAnIndex, 0);
  }
  flat::MeshCompressionMode compressionMode() const {
    return static_cast<flat::MeshCompressionMode>(GetField<uint8_t>(VT_COMPRESSIONMODE, 0));
  }
  bool mutate_compressionMode(flat::MeshCompressionMode _compressionMode) {
    return SetField<uint8_t>(VT_COMPRESSIONMODE, static_cast<uint8_t>(_compressionMode), 0);
  }
  uint32_t compressedSize() const {
    return GetField<uint32_t>(VT_COMPRESSEDSIZE, 0);
  }
  bool mutate_compressedSize(uint32_t _compressedSize) {
    return SetField<uint32_t>(VT_COMPRESSEDSIZE, _compressedSize, 0);
  }
  const flatbuffers::String *originalPath() const {
    return GetPointer<const flatbuffers::String *>(VT_ORIGINALPATH);
  }
  flatbuffers::String *mutable_originalPath() {
    return GetPointer<flatbuffers::String *>(VT_ORIGINALPATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MESHNAME) &&
           VerifyField<uint8_t>(verifier, VT_VERTEXORDERING) &&
           VerifyField<uint8_t>(verifier, VT_VERTEXFORMAT) &&
           VerifyField<uint64_t>(verifier, VT_VERTEXBUFFERSIZE) &&
           VerifyField<uint64_t>(verifier, VT_INDEXBUFFERSIZE) &&
           VerifyField<flat::Bounds>(verifier, VT_MESHBOUNDS) &&
           VerifyField<uint8_t>(verifier, VT_SIZEOFANINDEX) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSIONMODE) &&
           VerifyField<uint32_t>(verifier, VT_COMPRESSEDSIZE) &&
           VerifyOffset(verifier, VT_ORIGINALPATH) &&
           verifier.VerifyString(originalPath()) &&
           verifier.EndTable();
  }
};

struct MeshInfoBuilder {
  typedef MeshInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshName(uint64_t meshName) {
    fbb_.AddElement<uint64_t>(MeshInfo::VT_MESHNAME, meshName, 0);
  }
  void add_vertexOrdering(flat::VertexOrdering vertexOrdering) {
    fbb_.AddElement<uint8_t>(MeshInfo::VT_VERTEXORDERING, static_cast<uint8_t>(vertexOrdering), 0);
  }
  void add_vertexFormat(flat::VertexFormat vertexFormat) {
    fbb_.AddElement<uint8_t>(MeshInfo::VT_VERTEXFORMAT, static_cast<uint8_t>(vertexFormat), 0);
  }
  void add_vertexBufferSize(uint64_t vertexBufferSize) {
    fbb_.AddElement<uint64_t>(MeshInfo::VT_VERTEXBUFFERSIZE, vertexBufferSize, 0);
  }
  void add_indexBufferSize(uint64_t indexBufferSize) {
    fbb_.AddElement<uint64_t>(MeshInfo::VT_INDEXBUFFERSIZE, indexBufferSize, 0);
  }
  void add_meshBounds(const flat::Bounds *meshBounds) {
    fbb_.AddStruct(MeshInfo::VT_MESHBOUNDS, meshBounds);
  }
  void add_sizeOfAnIndex(uint8_t sizeOfAnIndex) {
    fbb_.AddElement<uint8_t>(MeshInfo::VT_SIZEOFANINDEX, sizeOfAnIndex, 0);
  }
  void add_compressionMode(flat::MeshCompressionMode compressionMode) {
    fbb_.AddElement<uint8_t>(MeshInfo::VT_COMPRESSIONMODE, static_cast<uint8_t>(compressionMode), 0);
  }
  void add_compressedSize(uint32_t compressedSize) {
    fbb_.AddElement<uint32_t>(MeshInfo::VT_COMPRESSEDSIZE, compressedSize, 0);
  }
  void add_originalPath(flatbuffers::Offset<flatbuffers::String> originalPath) {
    fbb_.AddOffset(MeshInfo::VT_ORIGINALPATH, originalPath);
  }
  explicit MeshInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshInfoBuilder &operator=(const MeshInfoBuilder &);
  flatbuffers::Offset<MeshInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshInfo> CreateMeshInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t meshName = 0,
    flat::VertexOrdering vertexOrdering = flat::VertexOrdering_INTERLEAVED,
    flat::VertexFormat vertexFormat = flat::VertexFormat_UNKNOWN,
    uint64_t vertexBufferSize = 0,
    uint64_t indexBufferSize = 0,
    const flat::Bounds *meshBounds = 0,
    uint8_t sizeOfAnIndex = 0,
    flat::MeshCompressionMode compressionMode = flat::MeshCompressionMode_NONE,
    uint32_t compressedSize = 0,
    flatbuffers::Offset<flatbuffers::String> originalPath = 0) {
  MeshInfoBuilder builder_(_fbb);
  builder_.add_indexBufferSize(indexBufferSize);
  builder_.add_vertexBufferSize(vertexBufferSize);
  builder_.add_meshName(meshName);
  builder_.add_originalPath(originalPath);
  builder_.add_compressedSize(compressedSize);
  builder_.add_meshBounds(meshBounds);
  builder_.add_compressionMode(compressionMode);
  builder_.add_sizeOfAnIndex(sizeOfAnIndex);
  builder_.add_vertexFormat(vertexFormat);
  builder_.add_vertexOrdering(vertexOrdering);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshInfo> CreateMeshInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t meshName = 0,
    flat::VertexOrdering vertexOrdering = flat::VertexOrdering_INTERLEAVED,
    flat::VertexFormat vertexFormat = flat::VertexFormat_UNKNOWN,
    uint64_t vertexBufferSize = 0,
    uint64_t indexBufferSize = 0,
    const flat::Bounds *meshBounds = 0,
    uint8_t sizeOfAnIndex = 0,
    flat::MeshCompressionMode compressionMode = flat::MeshCompressionMode_NONE,
    uint32_t compressedSize = 0,
    const char *originalPath = nullptr) {
  auto originalPath__ = originalPath ? _fbb.CreateString(originalPath) : 0;
  return flat::CreateMeshInfo(
      _fbb,
      meshName,
      vertexOrdering,
      vertexFormat,
      vertexBufferSize,
      indexBufferSize,
      meshBounds,
      sizeOfAnIndex,
      compressionMode,
      compressedSize,
      originalPath__);
}

struct RModelMetaData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RModelMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODELASSETNAME = 4,
    VT_MESHINFOS = 6,
    VT_MODELBOUNDS = 8,
    VT_NUMMESHES = 10,
    VT_NUMMATERIALS = 12,
    VT_NUMVERTICES = 14,
    VT_NUMINDICES = 16,
    VT_ISANIMATEDMODEL = 18,
    VT_BONEMETADATA = 20,
    VT_SKELETONMETADATA = 22,
    VT_ORIGINALPATH = 24,
    VT_ANIMATIONMETADATA = 26
  };
  const flat::AssetName *modelAssetName() const {
    return GetPointer<const flat::AssetName *>(VT_MODELASSETNAME);
  }
  flat::AssetName *mutable_modelAssetName() {
    return GetPointer<flat::AssetName *>(VT_MODELASSETNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::MeshInfo>> *meshInfos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::MeshInfo>> *>(VT_MESHINFOS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flat::MeshInfo>> *mutable_meshInfos() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flat::MeshInfo>> *>(VT_MESHINFOS);
  }
  const flat::Bounds *modelBounds() const {
    return GetStruct<const flat::Bounds *>(VT_MODELBOUNDS);
  }
  flat::Bounds *mutable_modelBounds() {
    return GetStruct<flat::Bounds *>(VT_MODELBOUNDS);
  }
  uint32_t numMeshes() const {
    return GetField<uint32_t>(VT_NUMMESHES, 0);
  }
  bool mutate_numMeshes(uint32_t _numMeshes) {
    return SetField<uint32_t>(VT_NUMMESHES, _numMeshes, 0);
  }
  uint32_t numMaterials() const {
    return GetField<uint32_t>(VT_NUMMATERIALS, 0);
  }
  bool mutate_numMaterials(uint32_t _numMaterials) {
    return SetField<uint32_t>(VT_NUMMATERIALS, _numMaterials, 0);
  }
  uint32_t numVertices() const {
    return GetField<uint32_t>(VT_NUMVERTICES, 0);
  }
  bool mutate_numVertices(uint32_t _numVertices) {
    return SetField<uint32_t>(VT_NUMVERTICES, _numVertices, 0);
  }
  uint32_t numIndices() const {
    return GetField<uint32_t>(VT_NUMINDICES, 0);
  }
  bool mutate_numIndices(uint32_t _numIndices) {
    return SetField<uint32_t>(VT_NUMINDICES, _numIndices, 0);
  }
  bool isAnimatedModel() const {
    return GetField<uint8_t>(VT_ISANIMATEDMODEL, 0) != 0;
  }
  bool mutate_isAnimatedModel(bool _isAnimatedModel) {
    return SetField<uint8_t>(VT_ISANIMATEDMODEL, static_cast<uint8_t>(_isAnimatedModel), 0);
  }
  const flat::BoneMetaData *boneMetaData() const {
    return GetPointer<const flat::BoneMetaData *>(VT_BONEMETADATA);
  }
  flat::BoneMetaData *mutable_boneMetaData() {
    return GetPointer<flat::BoneMetaData *>(VT_BONEMETADATA);
  }
  const flat::SkeletonMetaData *skeletonMetaData() const {
    return GetPointer<const flat::SkeletonMetaData *>(VT_SKELETONMETADATA);
  }
  flat::SkeletonMetaData *mutable_skeletonMetaData() {
    return GetPointer<flat::SkeletonMetaData *>(VT_SKELETONMETADATA);
  }
  const flatbuffers::String *originalPath() const {
    return GetPointer<const flatbuffers::String *>(VT_ORIGINALPATH);
  }
  flatbuffers::String *mutable_originalPath() {
    return GetPointer<flatbuffers::String *>(VT_ORIGINALPATH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::RAnimationMetaData>> *animationMetaData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::RAnimationMetaData>> *>(VT_ANIMATIONMETADATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<flat::RAnimationMetaData>> *mutable_animationMetaData() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flat::RAnimationMetaData>> *>(VT_ANIMATIONMETADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODELASSETNAME) &&
           verifier.VerifyTable(modelAssetName()) &&
           VerifyOffset(verifier, VT_MESHINFOS) &&
           verifier.VerifyVector(meshInfos()) &&
           verifier.VerifyVectorOfTables(meshInfos()) &&
           VerifyField<flat::Bounds>(verifier, VT_MODELBOUNDS) &&
           VerifyField<uint32_t>(verifier, VT_NUMMESHES) &&
           VerifyField<uint32_t>(verifier, VT_NUMMATERIALS) &&
           VerifyField<uint32_t>(verifier, VT_NUMVERTICES) &&
           VerifyField<uint32_t>(verifier, VT_NUMINDICES) &&
           VerifyField<uint8_t>(verifier, VT_ISANIMATEDMODEL) &&
           VerifyOffset(verifier, VT_BONEMETADATA) &&
           verifier.VerifyTable(boneMetaData()) &&
           VerifyOffset(verifier, VT_SKELETONMETADATA) &&
           verifier.VerifyTable(skeletonMetaData()) &&
           VerifyOffset(verifier, VT_ORIGINALPATH) &&
           verifier.VerifyString(originalPath()) &&
           VerifyOffset(verifier, VT_ANIMATIONMETADATA) &&
           verifier.VerifyVector(animationMetaData()) &&
           verifier.VerifyVectorOfTables(animationMetaData()) &&
           verifier.EndTable();
  }
};

struct RModelMetaDataBuilder {
  typedef RModelMetaData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modelAssetName(flatbuffers::Offset<flat::AssetName> modelAssetName) {
    fbb_.AddOffset(RModelMetaData::VT_MODELASSETNAME, modelAssetName);
  }
  void add_meshInfos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::MeshInfo>>> meshInfos) {
    fbb_.AddOffset(RModelMetaData::VT_MESHINFOS, meshInfos);
  }
  void add_modelBounds(const flat::Bounds *modelBounds) {
    fbb_.AddStruct(RModelMetaData::VT_MODELBOUNDS, modelBounds);
  }
  void add_numMeshes(uint32_t numMeshes) {
    fbb_.AddElement<uint32_t>(RModelMetaData::VT_NUMMESHES, numMeshes, 0);
  }
  void add_numMaterials(uint32_t numMaterials) {
    fbb_.AddElement<uint32_t>(RModelMetaData::VT_NUMMATERIALS, numMaterials, 0);
  }
  void add_numVertices(uint32_t numVertices) {
    fbb_.AddElement<uint32_t>(RModelMetaData::VT_NUMVERTICES, numVertices, 0);
  }
  void add_numIndices(uint32_t numIndices) {
    fbb_.AddElement<uint32_t>(RModelMetaData::VT_NUMINDICES, numIndices, 0);
  }
  void add_isAnimatedModel(bool isAnimatedModel) {
    fbb_.AddElement<uint8_t>(RModelMetaData::VT_ISANIMATEDMODEL, static_cast<uint8_t>(isAnimatedModel), 0);
  }
  void add_boneMetaData(flatbuffers::Offset<flat::BoneMetaData> boneMetaData) {
    fbb_.AddOffset(RModelMetaData::VT_BONEMETADATA, boneMetaData);
  }
  void add_skeletonMetaData(flatbuffers::Offset<flat::SkeletonMetaData> skeletonMetaData) {
    fbb_.AddOffset(RModelMetaData::VT_SKELETONMETADATA, skeletonMetaData);
  }
  void add_originalPath(flatbuffers::Offset<flatbuffers::String> originalPath) {
    fbb_.AddOffset(RModelMetaData::VT_ORIGINALPATH, originalPath);
  }
  void add_animationMetaData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::RAnimationMetaData>>> animationMetaData) {
    fbb_.AddOffset(RModelMetaData::VT_ANIMATIONMETADATA, animationMetaData);
  }
  explicit RModelMetaDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RModelMetaDataBuilder &operator=(const RModelMetaDataBuilder &);
  flatbuffers::Offset<RModelMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RModelMetaData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RModelMetaData> CreateRModelMetaData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flat::AssetName> modelAssetName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::MeshInfo>>> meshInfos = 0,
    const flat::Bounds *modelBounds = 0,
    uint32_t numMeshes = 0,
    uint32_t numMaterials = 0,
    uint32_t numVertices = 0,
    uint32_t numIndices = 0,
    bool isAnimatedModel = false,
    flatbuffers::Offset<flat::BoneMetaData> boneMetaData = 0,
    flatbuffers::Offset<flat::SkeletonMetaData> skeletonMetaData = 0,
    flatbuffers::Offset<flatbuffers::String> originalPath = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::RAnimationMetaData>>> animationMetaData = 0) {
  RModelMetaDataBuilder builder_(_fbb);
  builder_.add_animationMetaData(animationMetaData);
  builder_.add_originalPath(originalPath);
  builder_.add_skeletonMetaData(skeletonMetaData);
  builder_.add_boneMetaData(boneMetaData);
  builder_.add_numIndices(numIndices);
  builder_.add_numVertices(numVertices);
  builder_.add_numMaterials(numMaterials);
  builder_.add_numMeshes(numMeshes);
  builder_.add_modelBounds(modelBounds);
  builder_.add_meshInfos(meshInfos);
  builder_.add_modelAssetName(modelAssetName);
  builder_.add_isAnimatedModel(isAnimatedModel);
  return builder_.Finish();
}

inline flatbuffers::Offset<RModelMetaData> CreateRModelMetaDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flat::AssetName> modelAssetName = 0,
    const std::vector<flatbuffers::Offset<flat::MeshInfo>> *meshInfos = nullptr,
    const flat::Bounds *modelBounds = 0,
    uint32_t numMeshes = 0,
    uint32_t numMaterials = 0,
    uint32_t numVertices = 0,
    uint32_t numIndices = 0,
    bool isAnimatedModel = false,
    flatbuffers::Offset<flat::BoneMetaData> boneMetaData = 0,
    flatbuffers::Offset<flat::SkeletonMetaData> skeletonMetaData = 0,
    const char *originalPath = nullptr,
    const std::vector<flatbuffers::Offset<flat::RAnimationMetaData>> *animationMetaData = nullptr) {
  auto meshInfos__ = meshInfos ? _fbb.CreateVector<flatbuffers::Offset<flat::MeshInfo>>(*meshInfos) : 0;
  auto originalPath__ = originalPath ? _fbb.CreateString(originalPath) : 0;
  auto animationMetaData__ = animationMetaData ? _fbb.CreateVector<flatbuffers::Offset<flat::RAnimationMetaData>>(*animationMetaData) : 0;
  return flat::CreateRModelMetaData(
      _fbb,
      modelAssetName,
      meshInfos__,
      modelBounds,
      numMeshes,
      numMaterials,
      numVertices,
      numIndices,
      isAnimatedModel,
      boneMetaData,
      skeletonMetaData,
      originalPath__,
      animationMetaData__);
}

inline const flat::RModelMetaData *GetRModelMetaData(const void *buf) {
  return flatbuffers::GetRoot<flat::RModelMetaData>(buf);
}

inline const flat::RModelMetaData *GetSizePrefixedRModelMetaData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::RModelMetaData>(buf);
}

inline RModelMetaData *GetMutableRModelMetaData(void *buf) {
  return flatbuffers::GetMutableRoot<RModelMetaData>(buf);
}

inline const char *RModelMetaDataIdentifier() {
  return "mdmd";
}

inline bool RModelMetaDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, RModelMetaDataIdentifier());
}

inline bool VerifyRModelMetaDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::RModelMetaData>(RModelMetaDataIdentifier());
}

inline bool VerifySizePrefixedRModelMetaDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::RModelMetaData>(RModelMetaDataIdentifier());
}

inline const char *RModelMetaDataExtension() {
  return "mdmd";
}

inline void FinishRModelMetaDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RModelMetaData> root) {
  fbb.Finish(root, RModelMetaDataIdentifier());
}

inline void FinishSizePrefixedRModelMetaDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RModelMetaData> root) {
  fbb.FinishSizePrefixed(root, RModelMetaDataIdentifier());
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_RMODELMETADATA_FLAT_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RANIMATION_FLAT_H_
#define FLATBUFFERS_GENERATED_RANIMATION_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "Mesh_generated.h"

namespace flat {

struct Quaternion;

struct VectorKey;

struct RotationKey;

struct Channel;
struct ChannelBuilder;

struct RAnimation;
struct RAnimationBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quaternion() {
    memset(static_cast<void *>(this), 0, sizeof(Quaternion));
  }
  Quaternion(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
FLATBUFFERS_STRUCT_END(Quaternion, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) VectorKey FLATBUFFERS_FINAL_CLASS {
 private:
  double time_;
  flat::Vertex3 value_;
  int32_t padding0__;

 public:
  VectorKey() {
    memset(static_cast<void *>(this), 0, sizeof(VectorKey));
  }
  VectorKey(double _time, const flat::Vertex3 &_value)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(_value),
        padding0__(0) {
    (void)padding0__;
  }
  double time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(double _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  const flat::Vertex3 &value() const {
    return value_;
  }
  flat::Vertex3 &mutable_value() {
    return value_;
  }
};
FLATBUFFERS_STRUCT_END(VectorKey, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) RotationKey FLATBUFFERS_FINAL_CLASS {
 private:
  double time_;
  flat::Quaternion value_;

 public:
  RotationKey() {
    memset(static_cast<void *>(this), 0, sizeof(RotationKey));
  }
  RotationKey(double _time, const flat::Quaternion &_value)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(_value) {
  }
  double time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(double _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  const flat::Quaternion &value() const {
    return value_;
  }
  flat::Quaternion &mutable_value() {
    return value_;
  }
};
FLATBUFFERS_STRUCT_END(RotationKey, 24);

struct Channel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELNAME = 4,
    VT_POSITIONKEYS = 6,
    VT_SCALEKEYS = 8,
    VT_ROTATIONKEYS = 10
  };
  uint64_t channelName() const {
    return GetField<uint64_t>(VT_CHANNELNAME, 0);
  }
  bool mutate_channelName(uint64_t _channelName) {
    return SetField<uint64_t>(VT_CHANNELNAME, _channelName, 0);
  }
  const flatbuffers::Vector<const flat::VectorKey *> *positionKeys() const {
    return GetPointer<const flatbuffers::Vector<const flat::VectorKey *> *>(VT_POSITIONKEYS);
  }
  flatbuffers::Vector<const flat::VectorKey *> *mutable_positionKeys() {
    return GetPointer<flatbuffers::Vector<const flat::VectorKey *> *>(VT_POSITIONKEYS);
  }
  const flatbuffers::Vector<const flat::VectorKey *> *scaleKeys() const {
    return GetPointer<const flatbuffers::Vector<const flat::VectorKey *> *>(VT_SCALEKEYS);
  }
  flatbuffers::Vector<const flat::VectorKey *> *mutable_scaleKeys() {
    return GetPointer<flatbuffers::Vector<const flat::VectorKey *> *>(VT_SCALEKEYS);
  }
  const flatbuffers::Vector<const flat::RotationKey *> *rotationKeys() const {
    return GetPointer<const flatbuffers::Vector<const flat::RotationKey *> *>(VT_ROTATIONKEYS);
  }
  flatbuffers::Vector<const flat::RotationKey *> *mutable_rotationKeys() {
    return GetPointer<flatbuffers::Vector<const flat::RotationKey *> *>(VT_ROTATIONKEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHANNELNAME) &&
           VerifyOffset(verifier, VT_POSITIONKEYS) &&
           verifier.VerifyVector(positionKeys()) &&
           VerifyOffset(verifier, VT_SCALEKEYS) &&
           verifier.VerifyVector(scaleKeys()) &&
           VerifyOffset(verifier, VT_ROTATIONKEYS) &&
           verifier.VerifyVector(rotationKeys()) &&
           verifier.EndTable();
  }
};

struct ChannelBuilder {
  typedef Channel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channelName(uint64_t channelName) {
    fbb_.AddElement<uint64_t>(Channel::VT_CHANNELNAME, channelName, 0);
  }
  void add_positionKeys(flatbuffers::Offset<flatbuffers::Vector<const flat::VectorKey *>> positionKeys) {
    fbb_.AddOffset(Channel::VT_POSITIONKEYS, positionKeys);
  }
  void add_scaleKeys(flatbuffers::Offset<flatbuffers::Vector<const flat::VectorKey *>> scaleKeys) {
    fbb_.AddOffset(Channel::VT_SCALEKEYS, scaleKeys);
  }
  void add_rotationKeys(flatbuffers::Offset<flatbuffers::Vector<const flat::RotationKey *>> rotationKeys) {
    fbb_.AddOffset(Channel::VT_ROTATIONKEYS, rotationKeys);
  }
  explicit ChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChannelBuilder &operator=(const ChannelBuilder &);
  flatbuffers::Offset<Channel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Channel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Channel> CreateChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t channelName = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::VectorKey *>> positionKeys = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::VectorKey *>> scaleKeys = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::RotationKey *>> rotationKeys = 0) {
  ChannelBuilder builder_(_fbb);
  builder_.add_channelName(channelName);
  builder_.add_rotationKeys(rotationKeys);
  builder_.add_scaleKeys(scaleKeys);
  builder_.add_positionKeys(positionKeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<Channel> CreateChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t channelName = 0,
    const std::vector<flat::VectorKey> *positionKeys = nullptr,
    const std::vector<flat::VectorKey> *scaleKeys = nullptr,
    const std::vector<flat::RotationKey> *rotationKeys = nullptr) {
  auto positionKeys__ = positionKeys ? _fbb.CreateVectorOfStructs<flat::VectorKey>(*positionKeys) : 0;
  auto scaleKeys__ = scaleKeys ? _fbb.CreateVectorOfStructs<flat::VectorKey>(*scaleKeys) : 0;
  auto rotationKeys__ = rotationKeys ? _fbb.CreateVectorOfStructs<flat::RotationKey>(*rotationKeys) : 0;
  return flat::CreateChannel(
      _fbb,
      channelName,
      positionKeys__,
      scaleKeys__,
      rotationKeys__);
}

struct RAnimation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RAnimationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANIMATIONNAME = 4,
    VT_DURATIONINTICKS = 6,
    VT_TICKSPERSECONDS = 8,
    VT_CHANNELS = 10
  };
  uint64_t animationName() const {
    return GetField<uint64_t>(VT_ANIMATIONNAME, 0);
  }
  bool mutate_animationName(uint64_t _animationName) {
    return SetField<uint64_t>(VT_ANIMATIONNAME, _animationName, 0);
  }
  double durationInTicks() const {
    return GetField<double>(VT_DURATIONINTICKS, 0.0);
  }
  bool mutate_durationInTicks(double _durationInTicks) {
    return SetField<double>(VT_DURATIONINTICKS, _durationInTicks, 0.0);
  }
  double ticksPerSeconds() const {
    return GetField<double>(VT_TICKSPERSECONDS, 0.0);
  }
  bool mutate_ticksPerSeconds(double _ticksPerSeconds) {
    return SetField<double>(VT_TICKSPERSECONDS, _ticksPerSeconds, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::Channel>> *channels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::Channel>> *>(VT_CHANNELS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flat::Channel>> *mutable_channels() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flat::Channel>> *>(VT_CHANNELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ANIMATIONNAME) &&
           VerifyField<double>(verifier, VT_DURATIONINTICKS) &&
           VerifyField<double>(verifier, VT_TICKSPERSECONDS) &&
           VerifyOffset(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           verifier.EndTable();
  }
};

struct RAnimationBuilder {
  typedef RAnimation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_animationName(uint64_t animationName) {
    fbb_.AddElement<uint64_t>(RAnimation::VT_ANIMATIONNAME, animationName, 0);
  }
  void add_durationInTicks(double durationInTicks) {
    fbb_.AddElement<double>(RAnimation::VT_DURATIONINTICKS, durationInTicks, 0.0);
  }
  void add_ticksPerSeconds(double ticksPerSeconds) {
    fbb_.AddElement<double>(RAnimation::VT_TICKSPERSECONDS, ticksPerSeconds, 0.0);
  }
  void add_channels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Channel>>> channels) {
    fbb_.AddOffset(RAnimation::VT_CHANNELS, channels);
  }
  explicit RAnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RAnimationBuilder &operator=(const RAnimationBuilder &);
  flatbuffers::Offset<RAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RAnimation>(end);
    return o;
  }
};

inline flatbuffers::Offset<RAnimation> CreateRAnimation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t animationName = 0,
    double durationInTicks = 0.0,
    double ticksPerSeconds = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::Channel>>> channels = 0) {
  RAnimationBuilder builder_(_fbb);
  builder_.add_ticksPerSeconds(ticksPerSeconds);
  builder_.add_durationInTicks(durationInTicks);
  builder_.add_animationName(animationName);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<RAnimation> CreateRAnimationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t animationName = 0,
    double durationInTicks = 0.0,
    double ticksPerSeconds = 0.0,
    const std::vector<flatbuffers::Offset<flat::Channel>> *channels = nullptr) {
  auto channels__ = channels ? _fbb.CreateVector<flatbuffers::Offset<flat::Channel>>(*channels) : 0;
  return flat::CreateRAnimation(
      _fbb,
      animationName,
      durationInTicks,
      ticksPerSeconds,
      channels__);
}

inline const flat::RAnimation *GetRAnimation(const void *buf) {
  return flatbuffers::GetRoot<flat::RAnimation>(buf);
}

inline const flat::RAnimation *GetSizePrefixedRAnimation(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::RAnimation>(buf);
}

inline RAnimation *GetMutableRAnimation(void *buf) {
  return flatbuffers::GetMutableRoot<RAnimation>(buf);
}

inline const char *RAnimationIdentifier() {
  return "ranm";
}

inline bool RAnimationBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, RAnimationIdentifier());
}

inline bool VerifyRAnimationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::RAnimation>(RAnimationIdentifier());
}

inline bool VerifySizePrefixedRAnimationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::RAnimation>(RAnimationIdentifier());
}

inline const char *RAnimationExtension() {
  return "ranm";
}

inline void FinishRAnimationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RAnimation> root) {
  fbb.Finish(root, RAnimationIdentifier());
}

inline void FinishSizePrefixedRAnimationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RAnimation> root) {
  fbb.FinishSizePrefixed(root, RAnimationIdentifier());
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_RANIMATION_FLAT_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RANIMATION_FLAT_H_
#define FLATBUFFERS_GENERATED_RANIMATION_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "AssetName_generated.h"
#include "Mesh_generated.h"

namespace flat {

struct Quaternion;

struct ScalarKey;

struct VectorKey;

struct RotationKey;

struct TrackInfo;
struct TrackInfoBuilder;

struct ScalarTrack;
struct ScalarTrackBuilder;

struct VectorTrack;
struct VectorTrackBuilder;

struct QuaternionTrack;
struct QuaternionTrackBuilder;

struct TransformTrack;
struct TransformTrackBuilder;

struct RAnimation;
struct RAnimationBuilder;

enum InterpolationType {
  InterpolationType_CONSTANT = 0,
  InterpolationType_LINEAR = 1,
  InterpolationType_CUBIC = 2,
  InterpolationType_MIN = InterpolationType_CONSTANT,
  InterpolationType_MAX = InterpolationType_CUBIC
};

inline const InterpolationType (&EnumValuesInterpolationType())[3] {
  static const InterpolationType values[] = {
    InterpolationType_CONSTANT,
    InterpolationType_LINEAR,
    InterpolationType_CUBIC
  };
  return values;
}

inline const char * const *EnumNamesInterpolationType() {
  static const char * const names[4] = {
    "CONSTANT",
    "LINEAR",
    "CUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterpolationType(InterpolationType e) {
  if (flatbuffers::IsOutRange(e, InterpolationType_CONSTANT, InterpolationType_CUBIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterpolationType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quaternion() {
    memset(static_cast<void *>(this), 0, sizeof(Quaternion));
  }
  Quaternion(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
FLATBUFFERS_STRUCT_END(Quaternion, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ScalarKey FLATBUFFERS_FINAL_CLASS {
 private:
  double time_;
  double value_;
  double in_;
  double out_;

 public:
  ScalarKey() {
    memset(static_cast<void *>(this), 0, sizeof(ScalarKey));
  }
  ScalarKey(double _time, double _value, double _in, double _out)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(flatbuffers::EndianScalar(_value)),
        in_(flatbuffers::EndianScalar(_in)),
        out_(flatbuffers::EndianScalar(_out)) {
  }
  double time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(double _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  double value() const {
    return flatbuffers::EndianScalar(value_);
  }
  void mutate_value(double _value) {
    flatbuffers::WriteScalar(&value_, _value);
  }
  double in() const {
    return flatbuffers::EndianScalar(in_);
  }
  void mutate_in(double _in) {
    flatbuffers::WriteScalar(&in_, _in);
  }
  double out() const {
    return flatbuffers::EndianScalar(out_);
  }
  void mutate_out(double _out) {
    flatbuffers::WriteScalar(&out_, _out);
  }
};
FLATBUFFERS_STRUCT_END(ScalarKey, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) VectorKey FLATBUFFERS_FINAL_CLASS {
 private:
  double time_;
  flat::Vertex3 value_;
  flat::Vertex3 in_;
  flat::Vertex3 out_;
  int32_t padding0__;

 public:
  VectorKey() {
    memset(static_cast<void *>(this), 0, sizeof(VectorKey));
  }
  VectorKey(double _time, const flat::Vertex3 &_value, const flat::Vertex3 &_in, const flat::Vertex3 &_out)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(_value),
        in_(_in),
        out_(_out),
        padding0__(0) {
    (void)padding0__;
  }
  double time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(double _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  const flat::Vertex3 &value() const {
    return value_;
  }
  flat::Vertex3 &mutable_value() {
    return value_;
  }
  const flat::Vertex3 &in() const {
    return in_;
  }
  flat::Vertex3 &mutable_in() {
    return in_;
  }
  const flat::Vertex3 &out() const {
    return out_;
  }
  flat::Vertex3 &mutable_out() {
    return out_;
  }
};
FLATBUFFERS_STRUCT_END(VectorKey, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) RotationKey FLATBUFFERS_FINAL_CLASS {
 private:
  double time_;
  flat::Quaternion value_;
  flat::Quaternion in_;
  flat::Quaternion out_;

 public:
  RotationKey() {
    memset(static_cast<void *>(this), 0, sizeof(RotationKey));
  }
  RotationKey(double _time, const flat::Quaternion &_value, const flat::Quaternion &_in, const flat::Quaternion &_out)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(_value),
        in_(_in),
        out_(_out) {
  }
  double time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(double _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  const flat::Quaternion &value() const {
    return value_;
  }
  flat::Quaternion &mutable_value() {
    return value_;
  }
  const flat::Quaternion &in() const {
    return in_;
  }
  flat::Quaternion &mutable_in() {
    return in_;
  }
  const flat::Quaternion &out() const {
    return out_;
  }
  flat::Quaternion &mutable_out() {
    return out_;
  }
};
FLATBUFFERS_STRUCT_END(RotationKey, 56);

struct TrackInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrackInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERPOLATION = 4,
    VT_NUMBEROFSAMPLES = 6,
    VT_SAMPLEDKEYS = 8
  };
  flat::InterpolationType interpolation() const {
    return static_cast<flat::InterpolationType>(GetField<uint8_t>(VT_INTERPOLATION, 0));
  }
  bool mutate_interpolation(flat::InterpolationType _interpolation) {
    return SetField<uint8_t>(VT_INTERPOLATION, static_cast<uint8_t>(_interpolation), 0);
  }
  uint32_t numberOfSamples() const {
    return GetField<uint32_t>(VT_NUMBEROFSAMPLES, 0);
  }
  bool mutate_numberOfSamples(uint32_t _numberOfSamples) {
    return SetField<uint32_t>(VT_NUMBEROFSAMPLES, _numberOfSamples, 0);
  }
  const flatbuffers::Vector<uint32_t> *sampledKeys() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SAMPLEDKEYS);
  }
  flatbuffers::Vector<uint32_t> *mutable_sampledKeys() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_SAMPLEDKEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INTERPOLATION) &&
           VerifyField<uint32_t>(verifier, VT_NUMBEROFSAMPLES) &&
           VerifyOffset(verifier, VT_SAMPLEDKEYS) &&
           verifier.VerifyVector(sampledKeys()) &&
           verifier.EndTable();
  }
};

struct TrackInfoBuilder {
  typedef TrackInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_interpolation(flat::InterpolationType interpolation) {
    fbb_.AddElement<uint8_t>(TrackInfo::VT_INTERPOLATION, static_cast<uint8_t>(interpolation), 0);
  }
  void add_numberOfSamples(uint32_t numberOfSamples) {
    fbb_.AddElement<uint32_t>(TrackInfo::VT_NUMBEROFSAMPLES, numberOfSamples, 0);
  }
  void add_sampledKeys(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sampledKeys) {
    fbb_.AddOffset(TrackInfo::VT_SAMPLEDKEYS, sampledKeys);
  }
  explicit TrackInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TrackInfoBuilder &operator=(const TrackInfoBuilder &);
  flatbuffers::Offset<TrackInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrackInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrackInfo> CreateTrackInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::InterpolationType interpolation = flat::InterpolationType_CONSTANT,
    uint32_t numberOfSamples = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> sampledKeys = 0) {
  TrackInfoBuilder builder_(_fbb);
  builder_.add_sampledKeys(sampledKeys);
  builder_.add_numberOfSamples(numberOfSamples);
  builder_.add_interpolation(interpolation);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrackInfo> CreateTrackInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::InterpolationType interpolation = flat::InterpolationType_CONSTANT,
    uint32_t numberOfSamples = 0,
    const std::vector<uint32_t> *sampledKeys = nullptr) {
  auto sampledKeys__ = sampledKeys ? _fbb.CreateVector<uint32_t>(*sampledKeys) : 0;
  return flat::CreateTrackInfo(
      _fbb,
      interpolation,
      numberOfSamples,
      sampledKeys__);
}

struct ScalarTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_TRACKINFO = 6
  };
  const flatbuffers::Vector<const flat::ScalarKey *> *keys() const {
    return GetPointer<const flatbuffers::Vector<const flat::ScalarKey *> *>(VT_KEYS);
  }
  flatbuffers::Vector<const flat::ScalarKey *> *mutable_keys() {
    return GetPointer<flatbuffers::Vector<const flat::ScalarKey *> *>(VT_KEYS);
  }
  const flat::TrackInfo *trackInfo() const {
    return GetPointer<const flat::TrackInfo *>(VT_TRACKINFO);
  }
  flat::TrackInfo *mutable_trackInfo() {
    return GetPointer<flat::TrackInfo *>(VT_TRACKINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_TRACKINFO) &&
           verifier.VerifyTable(trackInfo()) &&
           verifier.EndTable();
  }
};

struct ScalarTrackBuilder {
  typedef ScalarTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<const flat::ScalarKey *>> keys) {
    fbb_.AddOffset(ScalarTrack::VT_KEYS, keys);
  }
  void add_trackInfo(flatbuffers::Offset<flat::TrackInfo> trackInfo) {
    fbb_.AddOffset(ScalarTrack::VT_TRACKINFO, trackInfo);
  }
  explicit ScalarTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScalarTrackBuilder &operator=(const ScalarTrackBuilder &);
  flatbuffers::Offset<ScalarTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarTrack> CreateScalarTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const flat::ScalarKey *>> keys = 0,
    flatbuffers::Offset<flat::TrackInfo> trackInfo = 0) {
  ScalarTrackBuilder builder_(_fbb);
  builder_.add_trackInfo(trackInfo);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScalarTrack> CreateScalarTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flat::ScalarKey> *keys = nullptr,
    flatbuffers::Offset<flat::TrackInfo> trackInfo = 0) {
  auto keys__ = keys ? _fbb.CreateVectorOfStructs<flat::ScalarKey>(*keys) : 0;
  return flat::CreateScalarTrack(
      _fbb,
      keys__,
      trackInfo);
}

struct VectorTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_TRACKINFO = 6
  };
  const flatbuffers::Vector<const flat::VectorKey *> *keys() const {
    return GetPointer<const flatbuffers::Vector<const flat::VectorKey *> *>(VT_KEYS);
  }
  flatbuffers::Vector<const flat::VectorKey *> *mutable_keys() {
    return GetPointer<flatbuffers::Vector<const flat::VectorKey *> *>(VT_KEYS);
  }
  const flat::TrackInfo *trackInfo() const {
    return GetPointer<const flat::TrackInfo *>(VT_TRACKINFO);
  }
  flat::TrackInfo *mutable_trackInfo() {
    return GetPointer<flat::TrackInfo *>(VT_TRACKINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_TRACKINFO) &&
           verifier.VerifyTable(trackInfo()) &&
           verifier.EndTable();
  }
};

struct VectorTrackBuilder {
  typedef VectorTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<const flat::VectorKey *>> keys) {
    fbb_.AddOffset(VectorTrack::VT_KEYS, keys);
  }
  void add_trackInfo(flatbuffers::Offset<flat::TrackInfo> trackInfo) {
    fbb_.AddOffset(VectorTrack::VT_TRACKINFO, trackInfo);
  }
  explicit VectorTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorTrackBuilder &operator=(const VectorTrackBuilder &);
  flatbuffers::Offset<VectorTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorTrack> CreateVectorTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const flat::VectorKey *>> keys = 0,
    flatbuffers::Offset<flat::TrackInfo> trackInfo = 0) {
  VectorTrackBuilder builder_(_fbb);
  builder_.add_trackInfo(trackInfo);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<VectorTrack> CreateVectorTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flat::VectorKey> *keys = nullptr,
    flatbuffers::Offset<flat::TrackInfo> trackInfo = 0) {
  auto keys__ = keys ? _fbb.CreateVectorOfStructs<flat::VectorKey>(*keys) : 0;
  return flat::CreateVectorTrack(
      _fbb,
      keys__,
      trackInfo);
}

struct QuaternionTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_TRACKINFO = 6
  };
  const flatbuffers::Vector<const flat::RotationKey *> *keys() const {
    return GetPointer<const flatbuffers::Vector<const flat::RotationKey *> *>(VT_KEYS);
  }
  flatbuffers::Vector<const flat::RotationKey *> *mutable_keys() {
    return GetPointer<flatbuffers::Vector<const flat::RotationKey *> *>(VT_KEYS);
  }
  const flat::TrackInfo *trackInfo() const {
    return GetPointer<const flat::TrackInfo *>(VT_TRACKINFO);
  }
  flat::TrackInfo *mutable_trackInfo() {
    return GetPointer<flat::TrackInfo *>(VT_TRACKINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyOffset(verifier, VT_TRACKINFO) &&
           verifier.VerifyTable(trackInfo()) &&
           verifier.EndTable();
  }
};

struct QuaternionTrackBuilder {
  typedef QuaternionTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<const flat::RotationKey *>> keys) {
    fbb_.AddOffset(QuaternionTrack::VT_KEYS, keys);
  }
  void add_trackInfo(flatbuffers::Offset<flat::TrackInfo> trackInfo) {
    fbb_.AddOffset(QuaternionTrack::VT_TRACKINFO, trackInfo);
  }
  explicit QuaternionTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionTrackBuilder &operator=(const QuaternionTrackBuilder &);
  flatbuffers::Offset<QuaternionTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuaternionTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuaternionTrack> CreateQuaternionTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const flat::RotationKey *>> keys = 0,
    flatbuffers::Offset<flat::TrackInfo> trackInfo = 0) {
  QuaternionTrackBuilder builder_(_fbb);
  builder_.add_trackInfo(trackInfo);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuaternionTrack> CreateQuaternionTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flat::RotationKey> *keys = nullptr,
    flatbuffers::Offset<flat::TrackInfo> trackInfo = 0) {
  auto keys__ = keys ? _fbb.CreateVectorOfStructs<flat::RotationKey>(*keys) : 0;
  return flat::CreateQuaternionTrack(
      _fbb,
      keys__,
      trackInfo);
}

struct TransformTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransformTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINTID = 4,
    VT_POSITIONTRACK = 6,
    VT_ROTATIONTRACK = 8,
    VT_SCALETRACK = 10,
    VT_STARTTIME = 12,
    VT_ENDTIME = 14
  };
  int32_t jointID() const {
    return GetField<int32_t>(VT_JOINTID, 0);
  }
  bool mutate_jointID(int32_t _jointID) {
    return SetField<int32_t>(VT_JOINTID, _jointID, 0);
  }
  const flat::VectorTrack *positionTrack() const {
    return GetPointer<const flat::VectorTrack *>(VT_POSITIONTRACK);
  }
  flat::VectorTrack *mutable_positionTrack() {
    return GetPointer<flat::VectorTrack *>(VT_POSITIONTRACK);
  }
  const flat::QuaternionTrack *rotationTrack() const {
    return GetPointer<const flat::QuaternionTrack *>(VT_ROTATIONTRACK);
  }
  flat::QuaternionTrack *mutable_rotationTrack() {
    return GetPointer<flat::QuaternionTrack *>(VT_ROTATIONTRACK);
  }
  const flat::VectorTrack *scaleTrack() const {
    return GetPointer<const flat::VectorTrack *>(VT_SCALETRACK);
  }
  flat::VectorTrack *mutable_scaleTrack() {
    return GetPointer<flat::VectorTrack *>(VT_SCALETRACK);
  }
  float startTime() const {
    return GetField<float>(VT_STARTTIME, 0.0f);
  }
  bool mutate_startTime(float _startTime) {
    return SetField<float>(VT_STARTTIME, _startTime, 0.0f);
  }
  float endTime() const {
    return GetField<float>(VT_ENDTIME, 0.0f);
  }
  bool mutate_endTime(float _endTime) {
    return SetField<float>(VT_ENDTIME, _endTime, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_JOINTID) &&
           VerifyOffset(verifier, VT_POSITIONTRACK) &&
           verifier.VerifyTable(positionTrack()) &&
           VerifyOffset(verifier, VT_ROTATIONTRACK) &&
           verifier.VerifyTable(rotationTrack()) &&
           VerifyOffset(verifier, VT_SCALETRACK) &&
           verifier.VerifyTable(scaleTrack()) &&
           VerifyField<float>(verifier, VT_STARTTIME) &&
           VerifyField<float>(verifier, VT_ENDTIME) &&
           verifier.EndTable();
  }
};

struct TransformTrackBuilder {
  typedef TransformTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_jointID(int32_t jointID) {
    fbb_.AddElement<int32_t>(TransformTrack::VT_JOINTID, jointID, 0);
  }
  void add_positionTrack(flatbuffers::Offset<flat::VectorTrack> positionTrack) {
    fbb_.AddOffset(TransformTrack::VT_POSITIONTRACK, positionTrack);
  }
  void add_rotationTrack(flatbuffers::Offset<flat::QuaternionTrack> rotationTrack) {
    fbb_.AddOffset(TransformTrack::VT_ROTATIONTRACK, rotationTrack);
  }
  void add_scaleTrack(flatbuffers::Offset<flat::VectorTrack> scaleTrack) {
    fbb_.AddOffset(TransformTrack::VT_SCALETRACK, scaleTrack);
  }
  void add_startTime(float startTime) {
    fbb_.AddElement<float>(TransformTrack::VT_STARTTIME, startTime, 0.0f);
  }
  void add_endTime(float endTime) {
    fbb_.AddElement<float>(TransformTrack::VT_ENDTIME, endTime, 0.0f);
  }
  explicit TransformTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransformTrackBuilder &operator=(const TransformTrackBuilder &);
  flatbuffers::Offset<TransformTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransformTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransformTrack> CreateTransformTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t jointID = 0,
    flatbuffers::Offset<flat::VectorTrack> positionTrack = 0,
    flatbuffers::Offset<flat::QuaternionTrack> rotationTrack = 0,
    flatbuffers::Offset<flat::VectorTrack> scaleTrack = 0,
    float startTime = 0.0f,
    float endTime = 0.0f) {
  TransformTrackBuilder builder_(_fbb);
  builder_.add_endTime(endTime);
  builder_.add_startTime(startTime);
  builder_.add_scaleTrack(scaleTrack);
  builder_.add_rotationTrack(rotationTrack);
  builder_.add_positionTrack(positionTrack);
  builder_.add_jointID(jointID);
  return builder_.Finish();
}

struct RAnimation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RAnimationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSETNAME = 4,
    VT_STARTTIME = 6,
    VT_ENDTIME = 8,
    VT_TRACKS = 10
  };
  const flat::AssetName *assetName() const {
    return GetPointer<const flat::AssetName *>(VT_ASSETNAME);
  }
  flat::AssetName *mutable_assetName() {
    return GetPointer<flat::AssetName *>(VT_ASSETNAME);
  }
  float startTime() const {
    return GetField<float>(VT_STARTTIME, 0.0f);
  }
  bool mutate_startTime(float _startTime) {
    return SetField<float>(VT_STARTTIME, _startTime, 0.0f);
  }
  float endTime() const {
    return GetField<float>(VT_ENDTIME, 0.0f);
  }
  bool mutate_endTime(float _endTime) {
    return SetField<float>(VT_ENDTIME, _endTime, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::TransformTrack>> *tracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::TransformTrack>> *>(VT_TRACKS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flat::TransformTrack>> *mutable_tracks() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flat::TransformTrack>> *>(VT_TRACKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSETNAME) &&
           verifier.VerifyTable(assetName()) &&
           VerifyField<float>(verifier, VT_STARTTIME) &&
           VerifyField<float>(verifier, VT_ENDTIME) &&
           VerifyOffset(verifier, VT_TRACKS) &&
           verifier.VerifyVector(tracks()) &&
           verifier.VerifyVectorOfTables(tracks()) &&
           verifier.EndTable();
  }
};

struct RAnimationBuilder {
  typedef RAnimation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_assetName(flatbuffers::Offset<flat::AssetName> assetName) {
    fbb_.AddOffset(RAnimation::VT_ASSETNAME, assetName);
  }
  void add_startTime(float startTime) {
    fbb_.AddElement<float>(RAnimation::VT_STARTTIME, startTime, 0.0f);
  }
  void add_endTime(float endTime) {
    fbb_.AddElement<float>(RAnimation::VT_ENDTIME, endTime, 0.0f);
  }
  void add_tracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::TransformTrack>>> tracks) {
    fbb_.AddOffset(RAnimation::VT_TRACKS, tracks);
  }
  explicit RAnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RAnimationBuilder &operator=(const RAnimationBuilder &);
  flatbuffers::Offset<RAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RAnimation>(end);
    return o;
  }
};

inline flatbuffers::Offset<RAnimation> CreateRAnimation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flat::AssetName> assetName = 0,
    float startTime = 0.0f,
    float endTime = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::TransformTrack>>> tracks = 0) {
  RAnimationBuilder builder_(_fbb);
  builder_.add_tracks(tracks);
  builder_.add_endTime(endTime);
  builder_.add_startTime(startTime);
  builder_.add_assetName(assetName);
  return builder_.Finish();
}

inline flatbuffers::Offset<RAnimation> CreateRAnimationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flat::AssetName> assetName = 0,
    float startTime = 0.0f,
    float endTime = 0.0f,
    const std::vector<flatbuffers::Offset<flat::TransformTrack>> *tracks = nullptr) {
  auto tracks__ = tracks ? _fbb.CreateVector<flatbuffers::Offset<flat::TransformTrack>>(*tracks) : 0;
  return flat::CreateRAnimation(
      _fbb,
      assetName,
      startTime,
      endTime,
      tracks__);
}

inline const flat::RAnimation *GetRAnimation(const void *buf) {
  return flatbuffers::GetRoot<flat::RAnimation>(buf);
}

inline const flat::RAnimation *GetSizePrefixedRAnimation(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::RAnimation>(buf);
}

inline RAnimation *GetMutableRAnimation(void *buf) {
  return flatbuffers::GetMutableRoot<RAnimation>(buf);
}

inline const char *RAnimationIdentifier() {
  return "ranm";
}

inline bool RAnimationBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, RAnimationIdentifier());
}

inline bool VerifyRAnimationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::RAnimation>(RAnimationIdentifier());
}

inline bool VerifySizePrefixedRAnimationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::RAnimation>(RAnimationIdentifier());
}

inline const char *RAnimationExtension() {
  return "ranm";
}

inline void FinishRAnimationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RAnimation> root) {
  fbb.Finish(root, RAnimationIdentifier());
}

inline void FinishSizePrefixedRAnimationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RAnimation> root) {
  fbb.FinishSizePrefixed(root, RAnimationIdentifier());
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_RANIMATION_FLAT_H_

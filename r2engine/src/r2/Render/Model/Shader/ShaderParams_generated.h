// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SHADERPARAMS_FLAT_H_
#define FLATBUFFERS_GENERATED_SHADERPARAMS_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "AssetName_generated.h"

namespace flat {

struct Colour;

struct ShaderFloatParam;
struct ShaderFloatParamBuilder;

struct ShaderColorParam;
struct ShaderColorParamBuilder;

struct ShaderBoolParam;
struct ShaderBoolParamBuilder;

struct ShaderULongParam;
struct ShaderULongParamBuilder;

struct ShaderStringParam;
struct ShaderStringParamBuilder;

struct ShaderStageParam;
struct ShaderStageParamBuilder;

struct ShaderTextureParam;
struct ShaderTextureParamBuilder;

struct ShaderParams;
struct ShaderParamsBuilder;

enum MinTextureFilter {
  MinTextureFilter_LINEAR = 0,
  MinTextureFilter_NEAREST = 1,
  MinTextureFilter_NEAREST_MIPMAP_NEAREST = 2,
  MinTextureFilter_LINEAR_MIPMAP_NEAREST = 3,
  MinTextureFilter_NEAREST_MIPMAP_LINEAR = 4,
  MinTextureFilter_LINEAR_MIPMAP_LINEAR = 5,
  MinTextureFilter_MIN = MinTextureFilter_LINEAR,
  MinTextureFilter_MAX = MinTextureFilter_LINEAR_MIPMAP_LINEAR
};

inline const MinTextureFilter (&EnumValuesMinTextureFilter())[6] {
  static const MinTextureFilter values[] = {
    MinTextureFilter_LINEAR,
    MinTextureFilter_NEAREST,
    MinTextureFilter_NEAREST_MIPMAP_NEAREST,
    MinTextureFilter_LINEAR_MIPMAP_NEAREST,
    MinTextureFilter_NEAREST_MIPMAP_LINEAR,
    MinTextureFilter_LINEAR_MIPMAP_LINEAR
  };
  return values;
}

inline const char * const *EnumNamesMinTextureFilter() {
  static const char * const names[7] = {
    "LINEAR",
    "NEAREST",
    "NEAREST_MIPMAP_NEAREST",
    "LINEAR_MIPMAP_NEAREST",
    "NEAREST_MIPMAP_LINEAR",
    "LINEAR_MIPMAP_LINEAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameMinTextureFilter(MinTextureFilter e) {
  if (flatbuffers::IsOutRange(e, MinTextureFilter_LINEAR, MinTextureFilter_LINEAR_MIPMAP_LINEAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMinTextureFilter()[index];
}

enum MagTextureFilter {
  MagTextureFilter_LINEAR = 0,
  MagTextureFilter_NEAREST = 1,
  MagTextureFilter_MIN = MagTextureFilter_LINEAR,
  MagTextureFilter_MAX = MagTextureFilter_NEAREST
};

inline const MagTextureFilter (&EnumValuesMagTextureFilter())[2] {
  static const MagTextureFilter values[] = {
    MagTextureFilter_LINEAR,
    MagTextureFilter_NEAREST
  };
  return values;
}

inline const char * const *EnumNamesMagTextureFilter() {
  static const char * const names[3] = {
    "LINEAR",
    "NEAREST",
    nullptr
  };
  return names;
}

inline const char *EnumNameMagTextureFilter(MagTextureFilter e) {
  if (flatbuffers::IsOutRange(e, MagTextureFilter_LINEAR, MagTextureFilter_NEAREST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMagTextureFilter()[index];
}

enum TextureWrapMode {
  TextureWrapMode_REPEAT = 0,
  TextureWrapMode_CLAMP_TO_EDGE = 1,
  TextureWrapMode_CLAMP_TO_BORDER = 2,
  TextureWrapMode_MIRRORED_REPEAT = 3,
  TextureWrapMode_MIN = TextureWrapMode_REPEAT,
  TextureWrapMode_MAX = TextureWrapMode_MIRRORED_REPEAT
};

inline const TextureWrapMode (&EnumValuesTextureWrapMode())[4] {
  static const TextureWrapMode values[] = {
    TextureWrapMode_REPEAT,
    TextureWrapMode_CLAMP_TO_EDGE,
    TextureWrapMode_CLAMP_TO_BORDER,
    TextureWrapMode_MIRRORED_REPEAT
  };
  return values;
}

inline const char * const *EnumNamesTextureWrapMode() {
  static const char * const names[5] = {
    "REPEAT",
    "CLAMP_TO_EDGE",
    "CLAMP_TO_BORDER",
    "MIRRORED_REPEAT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureWrapMode(TextureWrapMode e) {
  if (flatbuffers::IsOutRange(e, TextureWrapMode_REPEAT, TextureWrapMode_MIRRORED_REPEAT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureWrapMode()[index];
}

enum ShaderPropertyType {
  ShaderPropertyType_ALBEDO = 0,
  ShaderPropertyType_NORMAL = 1,
  ShaderPropertyType_EMISSION = 2,
  ShaderPropertyType_METALLIC = 3,
  ShaderPropertyType_ROUGHNESS = 4,
  ShaderPropertyType_AMBIENT_OCCLUSION = 5,
  ShaderPropertyType_HEIGHT = 6,
  ShaderPropertyType_ANISOTROPY = 7,
  ShaderPropertyType_ANISOTROPY_DIRECTION = 8,
  ShaderPropertyType_DETAIL = 9,
  ShaderPropertyType_HEIGHT_SCALE = 10,
  ShaderPropertyType_REFLECTANCE = 11,
  ShaderPropertyType_CLEAR_COAT = 12,
  ShaderPropertyType_CLEAR_COAT_ROUGHNESS = 13,
  ShaderPropertyType_CLEAR_COAT_NORMAL = 14,
  ShaderPropertyType_BENT_NORMAL = 15,
  ShaderPropertyType_SHEEN_COLOR = 16,
  ShaderPropertyType_SHEEN_ROUGHNESS = 17,
  ShaderPropertyType_DOUBLE_SIDED = 18,
  ShaderPropertyType_SHADER = 19,
  ShaderPropertyType_SHADER_DEFINE = 20,
  ShaderPropertyType_SHADER_MATERIAL_FUNCTION = 21,
  ShaderPropertyType_EMISSION_STRENGTH = 22,
  ShaderPropertyType_MIN = ShaderPropertyType_ALBEDO,
  ShaderPropertyType_MAX = ShaderPropertyType_EMISSION_STRENGTH
};

inline const ShaderPropertyType (&EnumValuesShaderPropertyType())[23] {
  static const ShaderPropertyType values[] = {
    ShaderPropertyType_ALBEDO,
    ShaderPropertyType_NORMAL,
    ShaderPropertyType_EMISSION,
    ShaderPropertyType_METALLIC,
    ShaderPropertyType_ROUGHNESS,
    ShaderPropertyType_AMBIENT_OCCLUSION,
    ShaderPropertyType_HEIGHT,
    ShaderPropertyType_ANISOTROPY,
    ShaderPropertyType_ANISOTROPY_DIRECTION,
    ShaderPropertyType_DETAIL,
    ShaderPropertyType_HEIGHT_SCALE,
    ShaderPropertyType_REFLECTANCE,
    ShaderPropertyType_CLEAR_COAT,
    ShaderPropertyType_CLEAR_COAT_ROUGHNESS,
    ShaderPropertyType_CLEAR_COAT_NORMAL,
    ShaderPropertyType_BENT_NORMAL,
    ShaderPropertyType_SHEEN_COLOR,
    ShaderPropertyType_SHEEN_ROUGHNESS,
    ShaderPropertyType_DOUBLE_SIDED,
    ShaderPropertyType_SHADER,
    ShaderPropertyType_SHADER_DEFINE,
    ShaderPropertyType_SHADER_MATERIAL_FUNCTION,
    ShaderPropertyType_EMISSION_STRENGTH
  };
  return values;
}

inline const char * const *EnumNamesShaderPropertyType() {
  static const char * const names[24] = {
    "ALBEDO",
    "NORMAL",
    "EMISSION",
    "METALLIC",
    "ROUGHNESS",
    "AMBIENT_OCCLUSION",
    "HEIGHT",
    "ANISOTROPY",
    "ANISOTROPY_DIRECTION",
    "DETAIL",
    "HEIGHT_SCALE",
    "REFLECTANCE",
    "CLEAR_COAT",
    "CLEAR_COAT_ROUGHNESS",
    "CLEAR_COAT_NORMAL",
    "BENT_NORMAL",
    "SHEEN_COLOR",
    "SHEEN_ROUGHNESS",
    "DOUBLE_SIDED",
    "SHADER",
    "SHADER_DEFINE",
    "SHADER_MATERIAL_FUNCTION",
    "EMISSION_STRENGTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameShaderPropertyType(ShaderPropertyType e) {
  if (flatbuffers::IsOutRange(e, ShaderPropertyType_ALBEDO, ShaderPropertyType_EMISSION_STRENGTH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShaderPropertyType()[index];
}

enum ShaderPropertyPackingType {
  ShaderPropertyPackingType_R = 0,
  ShaderPropertyPackingType_G = 1,
  ShaderPropertyPackingType_B = 2,
  ShaderPropertyPackingType_A = 3,
  ShaderPropertyPackingType_RGB = 4,
  ShaderPropertyPackingType_RGBA = 5,
  ShaderPropertyPackingType_MIN = ShaderPropertyPackingType_R,
  ShaderPropertyPackingType_MAX = ShaderPropertyPackingType_RGBA
};

inline const ShaderPropertyPackingType (&EnumValuesShaderPropertyPackingType())[6] {
  static const ShaderPropertyPackingType values[] = {
    ShaderPropertyPackingType_R,
    ShaderPropertyPackingType_G,
    ShaderPropertyPackingType_B,
    ShaderPropertyPackingType_A,
    ShaderPropertyPackingType_RGB,
    ShaderPropertyPackingType_RGBA
  };
  return values;
}

inline const char * const *EnumNamesShaderPropertyPackingType() {
  static const char * const names[7] = {
    "R",
    "G",
    "B",
    "A",
    "RGB",
    "RGBA",
    nullptr
  };
  return names;
}

inline const char *EnumNameShaderPropertyPackingType(ShaderPropertyPackingType e) {
  if (flatbuffers::IsOutRange(e, ShaderPropertyPackingType_R, ShaderPropertyPackingType_RGBA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShaderPropertyPackingType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Colour FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  Colour() {
    memset(static_cast<void *>(this), 0, sizeof(Colour));
  }
  Colour(float _r, float _g, float _b, float _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(Colour, 16);

struct ShaderFloatParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderFloatParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_VALUE = 6
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShaderFloatParamBuilder {
  typedef ShaderFloatParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderFloatParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(ShaderFloatParam::VT_VALUE, value, 0.0f);
  }
  explicit ShaderFloatParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderFloatParamBuilder &operator=(const ShaderFloatParamBuilder &);
  flatbuffers::Offset<ShaderFloatParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderFloatParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderFloatParam> CreateShaderFloatParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    float value = 0.0f) {
  ShaderFloatParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_propertyType(propertyType);
  return builder_.Finish();
}

struct ShaderColorParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderColorParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_VALUE = 6
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  const flat::Colour *value() const {
    return GetStruct<const flat::Colour *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyField<flat::Colour>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShaderColorParamBuilder {
  typedef ShaderColorParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderColorParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_value(const flat::Colour *value) {
    fbb_.AddStruct(ShaderColorParam::VT_VALUE, value);
  }
  explicit ShaderColorParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderColorParamBuilder &operator=(const ShaderColorParamBuilder &);
  flatbuffers::Offset<ShaderColorParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderColorParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderColorParam> CreateShaderColorParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    const flat::Colour *value = 0) {
  ShaderColorParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_propertyType(propertyType);
  return builder_.Finish();
}

struct ShaderBoolParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderBoolParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_VALUE = 6
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShaderBoolParamBuilder {
  typedef ShaderBoolParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderBoolParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(ShaderBoolParam::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit ShaderBoolParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderBoolParamBuilder &operator=(const ShaderBoolParamBuilder &);
  flatbuffers::Offset<ShaderBoolParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderBoolParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderBoolParam> CreateShaderBoolParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    bool value = false) {
  ShaderBoolParamBuilder builder_(_fbb);
  builder_.add_propertyType(propertyType);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ShaderULongParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderULongParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_VALUE = 6
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShaderULongParamBuilder {
  typedef ShaderULongParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderULongParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(ShaderULongParam::VT_VALUE, value, 0);
  }
  explicit ShaderULongParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderULongParamBuilder &operator=(const ShaderULongParamBuilder &);
  flatbuffers::Offset<ShaderULongParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderULongParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderULongParam> CreateShaderULongParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    uint64_t value = 0) {
  ShaderULongParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_propertyType(propertyType);
  return builder_.Finish();
}

struct ShaderStringParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderStringParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_VALUE = 6
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct ShaderStringParamBuilder {
  typedef ShaderStringParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderStringParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(ShaderStringParam::VT_VALUE, value);
  }
  explicit ShaderStringParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderStringParamBuilder &operator=(const ShaderStringParamBuilder &);
  flatbuffers::Offset<ShaderStringParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderStringParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderStringParam> CreateShaderStringParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  ShaderStringParamBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_propertyType(propertyType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderStringParam> CreateShaderStringParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flat::CreateShaderStringParam(
      _fbb,
      propertyType,
      value__);
}

struct ShaderStageParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderStageParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_SHADER = 6,
    VT_SHADERSTAGENAME = 8,
    VT_VALUE = 10
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  uint64_t shader() const {
    return GetField<uint64_t>(VT_SHADER, 0);
  }
  uint64_t shaderStageName() const {
    return GetField<uint64_t>(VT_SHADERSTAGENAME, 0);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyField<uint64_t>(verifier, VT_SHADER) &&
           VerifyField<uint64_t>(verifier, VT_SHADERSTAGENAME) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct ShaderStageParamBuilder {
  typedef ShaderStageParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderStageParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_shader(uint64_t shader) {
    fbb_.AddElement<uint64_t>(ShaderStageParam::VT_SHADER, shader, 0);
  }
  void add_shaderStageName(uint64_t shaderStageName) {
    fbb_.AddElement<uint64_t>(ShaderStageParam::VT_SHADERSTAGENAME, shaderStageName, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(ShaderStageParam::VT_VALUE, value);
  }
  explicit ShaderStageParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderStageParamBuilder &operator=(const ShaderStageParamBuilder &);
  flatbuffers::Offset<ShaderStageParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderStageParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderStageParam> CreateShaderStageParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    uint64_t shader = 0,
    uint64_t shaderStageName = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  ShaderStageParamBuilder builder_(_fbb);
  builder_.add_shaderStageName(shaderStageName);
  builder_.add_shader(shader);
  builder_.add_value(value);
  builder_.add_propertyType(propertyType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderStageParam> CreateShaderStageParamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    uint64_t shader = 0,
    uint64_t shaderStageName = 0,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flat::CreateShaderStageParam(
      _fbb,
      propertyType,
      shader,
      shaderStageName,
      value__);
}

struct ShaderTextureParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderTextureParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYTYPE = 4,
    VT_VALUE = 6,
    VT_PACKINGTYPE = 8,
    VT_TEXTUREPACK = 10,
    VT_MINFILTER = 12,
    VT_MAGFILTER = 14,
    VT_ANISOTROPICFILTERING = 16,
    VT_WRAPS = 18,
    VT_WRAPT = 20,
    VT_WRAPR = 22
  };
  flat::ShaderPropertyType propertyType() const {
    return static_cast<flat::ShaderPropertyType>(GetField<uint16_t>(VT_PROPERTYTYPE, 0));
  }
  const flat::AssetName *value() const {
    return GetPointer<const flat::AssetName *>(VT_VALUE);
  }
  flat::ShaderPropertyPackingType packingType() const {
    return static_cast<flat::ShaderPropertyPackingType>(GetField<int8_t>(VT_PACKINGTYPE, 0));
  }
  const flat::AssetName *texturePack() const {
    return GetPointer<const flat::AssetName *>(VT_TEXTUREPACK);
  }
  flat::MinTextureFilter minFilter() const {
    return static_cast<flat::MinTextureFilter>(GetField<uint8_t>(VT_MINFILTER, 0));
  }
  flat::MagTextureFilter magFilter() const {
    return static_cast<flat::MagTextureFilter>(GetField<uint8_t>(VT_MAGFILTER, 0));
  }
  float anisotropicFiltering() const {
    return GetField<float>(VT_ANISOTROPICFILTERING, 0.0f);
  }
  flat::TextureWrapMode wrapS() const {
    return static_cast<flat::TextureWrapMode>(GetField<uint8_t>(VT_WRAPS, 0));
  }
  flat::TextureWrapMode wrapT() const {
    return static_cast<flat::TextureWrapMode>(GetField<uint8_t>(VT_WRAPT, 0));
  }
  flat::TextureWrapMode wrapR() const {
    return static_cast<flat::TextureWrapMode>(GetField<uint8_t>(VT_WRAPR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PROPERTYTYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyField<int8_t>(verifier, VT_PACKINGTYPE) &&
           VerifyOffset(verifier, VT_TEXTUREPACK) &&
           verifier.VerifyTable(texturePack()) &&
           VerifyField<uint8_t>(verifier, VT_MINFILTER) &&
           VerifyField<uint8_t>(verifier, VT_MAGFILTER) &&
           VerifyField<float>(verifier, VT_ANISOTROPICFILTERING) &&
           VerifyField<uint8_t>(verifier, VT_WRAPS) &&
           VerifyField<uint8_t>(verifier, VT_WRAPT) &&
           VerifyField<uint8_t>(verifier, VT_WRAPR) &&
           verifier.EndTable();
  }
};

struct ShaderTextureParamBuilder {
  typedef ShaderTextureParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyType(flat::ShaderPropertyType propertyType) {
    fbb_.AddElement<uint16_t>(ShaderTextureParam::VT_PROPERTYTYPE, static_cast<uint16_t>(propertyType), 0);
  }
  void add_value(flatbuffers::Offset<flat::AssetName> value) {
    fbb_.AddOffset(ShaderTextureParam::VT_VALUE, value);
  }
  void add_packingType(flat::ShaderPropertyPackingType packingType) {
    fbb_.AddElement<int8_t>(ShaderTextureParam::VT_PACKINGTYPE, static_cast<int8_t>(packingType), 0);
  }
  void add_texturePack(flatbuffers::Offset<flat::AssetName> texturePack) {
    fbb_.AddOffset(ShaderTextureParam::VT_TEXTUREPACK, texturePack);
  }
  void add_minFilter(flat::MinTextureFilter minFilter) {
    fbb_.AddElement<uint8_t>(ShaderTextureParam::VT_MINFILTER, static_cast<uint8_t>(minFilter), 0);
  }
  void add_magFilter(flat::MagTextureFilter magFilter) {
    fbb_.AddElement<uint8_t>(ShaderTextureParam::VT_MAGFILTER, static_cast<uint8_t>(magFilter), 0);
  }
  void add_anisotropicFiltering(float anisotropicFiltering) {
    fbb_.AddElement<float>(ShaderTextureParam::VT_ANISOTROPICFILTERING, anisotropicFiltering, 0.0f);
  }
  void add_wrapS(flat::TextureWrapMode wrapS) {
    fbb_.AddElement<uint8_t>(ShaderTextureParam::VT_WRAPS, static_cast<uint8_t>(wrapS), 0);
  }
  void add_wrapT(flat::TextureWrapMode wrapT) {
    fbb_.AddElement<uint8_t>(ShaderTextureParam::VT_WRAPT, static_cast<uint8_t>(wrapT), 0);
  }
  void add_wrapR(flat::TextureWrapMode wrapR) {
    fbb_.AddElement<uint8_t>(ShaderTextureParam::VT_WRAPR, static_cast<uint8_t>(wrapR), 0);
  }
  explicit ShaderTextureParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderTextureParamBuilder &operator=(const ShaderTextureParamBuilder &);
  flatbuffers::Offset<ShaderTextureParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderTextureParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderTextureParam> CreateShaderTextureParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    flat::ShaderPropertyType propertyType = flat::ShaderPropertyType_ALBEDO,
    flatbuffers::Offset<flat::AssetName> value = 0,
    flat::ShaderPropertyPackingType packingType = flat::ShaderPropertyPackingType_R,
    flatbuffers::Offset<flat::AssetName> texturePack = 0,
    flat::MinTextureFilter minFilter = flat::MinTextureFilter_LINEAR,
    flat::MagTextureFilter magFilter = flat::MagTextureFilter_LINEAR,
    float anisotropicFiltering = 0.0f,
    flat::TextureWrapMode wrapS = flat::TextureWrapMode_REPEAT,
    flat::TextureWrapMode wrapT = flat::TextureWrapMode_REPEAT,
    flat::TextureWrapMode wrapR = flat::TextureWrapMode_REPEAT) {
  ShaderTextureParamBuilder builder_(_fbb);
  builder_.add_anisotropicFiltering(anisotropicFiltering);
  builder_.add_texturePack(texturePack);
  builder_.add_value(value);
  builder_.add_propertyType(propertyType);
  builder_.add_wrapR(wrapR);
  builder_.add_wrapT(wrapT);
  builder_.add_wrapS(wrapS);
  builder_.add_magFilter(magFilter);
  builder_.add_minFilter(minFilter);
  builder_.add_packingType(packingType);
  return builder_.Finish();
}

struct ShaderParams FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ULONGPARAMS = 4,
    VT_BOOLPARAMS = 6,
    VT_FLOATPARAMS = 8,
    VT_COLORPARAMS = 10,
    VT_TEXTUREPARAMS = 12,
    VT_STRINGPARAMS = 14,
    VT_SHADERSTAGEPARAMS = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderULongParam>> *ulongParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderULongParam>> *>(VT_ULONGPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderBoolParam>> *boolParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderBoolParam>> *>(VT_BOOLPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderFloatParam>> *floatParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderFloatParam>> *>(VT_FLOATPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderColorParam>> *colorParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderColorParam>> *>(VT_COLORPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderTextureParam>> *textureParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderTextureParam>> *>(VT_TEXTUREPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStringParam>> *stringParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStringParam>> *>(VT_STRINGPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStageParam>> *shaderStageParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStageParam>> *>(VT_SHADERSTAGEPARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ULONGPARAMS) &&
           verifier.VerifyVector(ulongParams()) &&
           verifier.VerifyVectorOfTables(ulongParams()) &&
           VerifyOffset(verifier, VT_BOOLPARAMS) &&
           verifier.VerifyVector(boolParams()) &&
           verifier.VerifyVectorOfTables(boolParams()) &&
           VerifyOffset(verifier, VT_FLOATPARAMS) &&
           verifier.VerifyVector(floatParams()) &&
           verifier.VerifyVectorOfTables(floatParams()) &&
           VerifyOffset(verifier, VT_COLORPARAMS) &&
           verifier.VerifyVector(colorParams()) &&
           verifier.VerifyVectorOfTables(colorParams()) &&
           VerifyOffset(verifier, VT_TEXTUREPARAMS) &&
           verifier.VerifyVector(textureParams()) &&
           verifier.VerifyVectorOfTables(textureParams()) &&
           VerifyOffset(verifier, VT_STRINGPARAMS) &&
           verifier.VerifyVector(stringParams()) &&
           verifier.VerifyVectorOfTables(stringParams()) &&
           VerifyOffset(verifier, VT_SHADERSTAGEPARAMS) &&
           verifier.VerifyVector(shaderStageParams()) &&
           verifier.VerifyVectorOfTables(shaderStageParams()) &&
           verifier.EndTable();
  }
};

struct ShaderParamsBuilder {
  typedef ShaderParams Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ulongParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderULongParam>>> ulongParams) {
    fbb_.AddOffset(ShaderParams::VT_ULONGPARAMS, ulongParams);
  }
  void add_boolParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderBoolParam>>> boolParams) {
    fbb_.AddOffset(ShaderParams::VT_BOOLPARAMS, boolParams);
  }
  void add_floatParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderFloatParam>>> floatParams) {
    fbb_.AddOffset(ShaderParams::VT_FLOATPARAMS, floatParams);
  }
  void add_colorParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderColorParam>>> colorParams) {
    fbb_.AddOffset(ShaderParams::VT_COLORPARAMS, colorParams);
  }
  void add_textureParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderTextureParam>>> textureParams) {
    fbb_.AddOffset(ShaderParams::VT_TEXTUREPARAMS, textureParams);
  }
  void add_stringParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStringParam>>> stringParams) {
    fbb_.AddOffset(ShaderParams::VT_STRINGPARAMS, stringParams);
  }
  void add_shaderStageParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStageParam>>> shaderStageParams) {
    fbb_.AddOffset(ShaderParams::VT_SHADERSTAGEPARAMS, shaderStageParams);
  }
  explicit ShaderParamsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderParamsBuilder &operator=(const ShaderParamsBuilder &);
  flatbuffers::Offset<ShaderParams> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderParams>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderParams> CreateShaderParams(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderULongParam>>> ulongParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderBoolParam>>> boolParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderFloatParam>>> floatParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderColorParam>>> colorParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderTextureParam>>> textureParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStringParam>>> stringParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::ShaderStageParam>>> shaderStageParams = 0) {
  ShaderParamsBuilder builder_(_fbb);
  builder_.add_shaderStageParams(shaderStageParams);
  builder_.add_stringParams(stringParams);
  builder_.add_textureParams(textureParams);
  builder_.add_colorParams(colorParams);
  builder_.add_floatParams(floatParams);
  builder_.add_boolParams(boolParams);
  builder_.add_ulongParams(ulongParams);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderParams> CreateShaderParamsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::ShaderULongParam>> *ulongParams = nullptr,
    const std::vector<flatbuffers::Offset<flat::ShaderBoolParam>> *boolParams = nullptr,
    const std::vector<flatbuffers::Offset<flat::ShaderFloatParam>> *floatParams = nullptr,
    const std::vector<flatbuffers::Offset<flat::ShaderColorParam>> *colorParams = nullptr,
    const std::vector<flatbuffers::Offset<flat::ShaderTextureParam>> *textureParams = nullptr,
    const std::vector<flatbuffers::Offset<flat::ShaderStringParam>> *stringParams = nullptr,
    const std::vector<flatbuffers::Offset<flat::ShaderStageParam>> *shaderStageParams = nullptr) {
  auto ulongParams__ = ulongParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderULongParam>>(*ulongParams) : 0;
  auto boolParams__ = boolParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderBoolParam>>(*boolParams) : 0;
  auto floatParams__ = floatParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderFloatParam>>(*floatParams) : 0;
  auto colorParams__ = colorParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderColorParam>>(*colorParams) : 0;
  auto textureParams__ = textureParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderTextureParam>>(*textureParams) : 0;
  auto stringParams__ = stringParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderStringParam>>(*stringParams) : 0;
  auto shaderStageParams__ = shaderStageParams ? _fbb.CreateVector<flatbuffers::Offset<flat::ShaderStageParam>>(*shaderStageParams) : 0;
  return flat::CreateShaderParams(
      _fbb,
      ulongParams__,
      boolParams__,
      floatParams__,
      colorParams__,
      textureParams__,
      stringParams__,
      shaderStageParams__);
}

inline const flat::ShaderParams *GetShaderParams(const void *buf) {
  return flatbuffers::GetRoot<flat::ShaderParams>(buf);
}

inline const flat::ShaderParams *GetSizePrefixedShaderParams(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::ShaderParams>(buf);
}

inline const char *ShaderParamsIdentifier() {
  return "sprm";
}

inline bool ShaderParamsBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ShaderParamsIdentifier());
}

inline bool VerifyShaderParamsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::ShaderParams>(ShaderParamsIdentifier());
}

inline bool VerifySizePrefixedShaderParamsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::ShaderParams>(ShaderParamsIdentifier());
}

inline const char *ShaderParamsExtension() {
  return "sprm";
}

inline void FinishShaderParamsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::ShaderParams> root) {
  fbb.Finish(root, ShaderParamsIdentifier());
}

inline void FinishSizePrefixedShaderParamsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::ShaderParams> root) {
  fbb.FinishSizePrefixed(root, ShaderParamsIdentifier());
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_SHADERPARAMS_FLAT_H_

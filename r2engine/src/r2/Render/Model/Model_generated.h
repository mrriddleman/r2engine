// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_R2_H_
#define FLATBUFFERS_GENERATED_MODEL_R2_H_

#include "flatbuffers/flatbuffers.h"

#include "Material_generated.h"

namespace r2 {

struct Vertex3;

struct Vertex2;

struct Face;
struct FaceBuilder;

struct Mesh;
struct MeshBuilder;

struct Model;
struct ModelBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vertex3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vertex3() {
    memset(static_cast<void *>(this), 0, sizeof(Vertex3));
  }
  Vertex3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vertex3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vertex2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vertex2() {
    memset(static_cast<void *>(this), 0, sizeof(Vertex2));
  }
  Vertex2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vertex2, 8);

struct Face FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMINDICES = 4,
    VT_INDICES = 6
  };
  uint64_t numIndices() const {
    return GetField<uint64_t>(VT_NUMINDICES, 0);
  }
  const flatbuffers::Vector<uint32_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NUMINDICES) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
};

struct FaceBuilder {
  typedef Face Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numIndices(uint64_t numIndices) {
    fbb_.AddElement<uint64_t>(Face::VT_NUMINDICES, numIndices, 0);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices) {
    fbb_.AddOffset(Face::VT_INDICES, indices);
  }
  explicit FaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FaceBuilder &operator=(const FaceBuilder &);
  flatbuffers::Offset<Face> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Face>(end);
    return o;
  }
};

inline flatbuffers::Offset<Face> CreateFace(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t numIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> indices = 0) {
  FaceBuilder builder_(_fbb);
  builder_.add_numIndices(numIndices);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<Face> CreateFaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t numIndices = 0,
    const std::vector<uint32_t> *indices = nullptr) {
  auto indices__ = indices ? _fbb.CreateVector<uint32_t>(*indices) : 0;
  return r2::CreateFace(
      _fbb,
      numIndices,
      indices__);
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMVERTICES = 4,
    VT_NUMFACES = 6,
    VT_POSITIONS = 8,
    VT_NORMALS = 10,
    VT_TEXTURECOORDS = 12,
    VT_FACES = 14
  };
  uint64_t numVertices() const {
    return GetField<uint64_t>(VT_NUMVERTICES, 0);
  }
  uint64_t numFaces() const {
    return GetField<uint64_t>(VT_NUMFACES, 0);
  }
  const flatbuffers::Vector<const r2::Vertex3 *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const r2::Vertex3 *> *>(VT_POSITIONS);
  }
  const flatbuffers::Vector<const r2::Vertex3 *> *normals() const {
    return GetPointer<const flatbuffers::Vector<const r2::Vertex3 *> *>(VT_NORMALS);
  }
  const flatbuffers::Vector<const r2::Vertex2 *> *textureCoords() const {
    return GetPointer<const flatbuffers::Vector<const r2::Vertex2 *> *>(VT_TEXTURECOORDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<r2::Face>> *faces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<r2::Face>> *>(VT_FACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NUMVERTICES) &&
           VerifyField<uint64_t>(verifier, VT_NUMFACES) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           VerifyOffset(verifier, VT_NORMALS) &&
           verifier.VerifyVector(normals()) &&
           VerifyOffset(verifier, VT_TEXTURECOORDS) &&
           verifier.VerifyVector(textureCoords()) &&
           VerifyOffset(verifier, VT_FACES) &&
           verifier.VerifyVector(faces()) &&
           verifier.VerifyVectorOfTables(faces()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  typedef Mesh Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numVertices(uint64_t numVertices) {
    fbb_.AddElement<uint64_t>(Mesh::VT_NUMVERTICES, numVertices, 0);
  }
  void add_numFaces(uint64_t numFaces) {
    fbb_.AddElement<uint64_t>(Mesh::VT_NUMFACES, numFaces, 0);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const r2::Vertex3 *>> positions) {
    fbb_.AddOffset(Mesh::VT_POSITIONS, positions);
  }
  void add_normals(flatbuffers::Offset<flatbuffers::Vector<const r2::Vertex3 *>> normals) {
    fbb_.AddOffset(Mesh::VT_NORMALS, normals);
  }
  void add_textureCoords(flatbuffers::Offset<flatbuffers::Vector<const r2::Vertex2 *>> textureCoords) {
    fbb_.AddOffset(Mesh::VT_TEXTURECOORDS, textureCoords);
  }
  void add_faces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<r2::Face>>> faces) {
    fbb_.AddOffset(Mesh::VT_FACES, faces);
  }
  explicit MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t numVertices = 0,
    uint64_t numFaces = 0,
    flatbuffers::Offset<flatbuffers::Vector<const r2::Vertex3 *>> positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<const r2::Vertex3 *>> normals = 0,
    flatbuffers::Offset<flatbuffers::Vector<const r2::Vertex2 *>> textureCoords = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<r2::Face>>> faces = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_numFaces(numFaces);
  builder_.add_numVertices(numVertices);
  builder_.add_faces(faces);
  builder_.add_textureCoords(textureCoords);
  builder_.add_normals(normals);
  builder_.add_positions(positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mesh> CreateMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t numVertices = 0,
    uint64_t numFaces = 0,
    const std::vector<r2::Vertex3> *positions = nullptr,
    const std::vector<r2::Vertex3> *normals = nullptr,
    const std::vector<r2::Vertex2> *textureCoords = nullptr,
    const std::vector<flatbuffers::Offset<r2::Face>> *faces = nullptr) {
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<r2::Vertex3>(*positions) : 0;
  auto normals__ = normals ? _fbb.CreateVectorOfStructs<r2::Vertex3>(*normals) : 0;
  auto textureCoords__ = textureCoords ? _fbb.CreateVectorOfStructs<r2::Vertex2>(*textureCoords) : 0;
  auto faces__ = faces ? _fbb.CreateVector<flatbuffers::Offset<r2::Face>>(*faces) : 0;
  return r2::CreateMesh(
      _fbb,
      numVertices,
      numFaces,
      positions__,
      normals__,
      textureCoords__,
      faces__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHES = 4,
    VT_MATERIAL = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<r2::Mesh>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<r2::Mesh>> *>(VT_MESHES);
  }
  const r2::Material *material() const {
    return GetPointer<const r2::Material *>(VT_MATERIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<r2::Mesh>>> meshes) {
    fbb_.AddOffset(Model::VT_MESHES, meshes);
  }
  void add_material(flatbuffers::Offset<r2::Material> material) {
    fbb_.AddOffset(Model::VT_MATERIAL, material);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<r2::Mesh>>> meshes = 0,
    flatbuffers::Offset<r2::Material> material = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_material(material);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<r2::Mesh>> *meshes = nullptr,
    flatbuffers::Offset<r2::Material> material = 0) {
  auto meshes__ = meshes ? _fbb.CreateVector<flatbuffers::Offset<r2::Mesh>>(*meshes) : 0;
  return r2::CreateModel(
      _fbb,
      meshes__,
      material);
}

inline const r2::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<r2::Model>(buf);
}

inline const r2::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<r2::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "modl";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<r2::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<r2::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "modl";
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<r2::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<r2::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

}  // namespace r2

#endif  // FLATBUFFERS_GENERATED_MODEL_R2_H_

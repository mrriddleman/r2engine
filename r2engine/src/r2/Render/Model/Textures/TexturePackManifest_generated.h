// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTUREPACKMANIFEST_FLAT_H_
#define FLATBUFFERS_GENERATED_TEXTUREPACKMANIFEST_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "TexturePackMetaData_generated.h"

namespace flat {

struct TexturePack;
struct TexturePackBuilder;

struct TexturePacksManifest;
struct TexturePacksManifestBuilder;

struct TexturePack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TexturePackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKNAME = 4,
    VT_ALBEDO = 6,
    VT_NORMAL = 8,
    VT_EMISSIVE = 10,
    VT_METALLIC = 12,
    VT_OCCLUSION = 14,
    VT_ROUGHNESS = 16,
    VT_HEIGHT = 18,
    VT_ANISOTROPY = 20,
    VT_DETAIL = 22,
    VT_PACKSIZE = 24,
    VT_TOTALNUMBEROFTEXTURES = 26,
    VT_METADATA = 28
  };
  uint64_t packName() const {
    return GetField<uint64_t>(VT_PACKNAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *albedo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALBEDO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *normal() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NORMAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *emissive() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EMISSIVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *metallic() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_METALLIC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *occlusion() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OCCLUSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *roughness() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ROUGHNESS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *height() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEIGHT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *anisotropy() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ANISOTROPY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *detail() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DETAIL);
  }
  uint64_t packSize() const {
    return GetField<uint64_t>(VT_PACKSIZE, 0);
  }
  uint64_t totalNumberOfTextures() const {
    return GetField<uint64_t>(VT_TOTALNUMBEROFTEXTURES, 0);
  }
  const flat::TexturePackMetaData *metaData() const {
    return GetPointer<const flat::TexturePackMetaData *>(VT_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKNAME) &&
           VerifyOffset(verifier, VT_ALBEDO) &&
           verifier.VerifyVector(albedo()) &&
           verifier.VerifyVectorOfStrings(albedo()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(normal()) &&
           verifier.VerifyVectorOfStrings(normal()) &&
           VerifyOffset(verifier, VT_EMISSIVE) &&
           verifier.VerifyVector(emissive()) &&
           verifier.VerifyVectorOfStrings(emissive()) &&
           VerifyOffset(verifier, VT_METALLIC) &&
           verifier.VerifyVector(metallic()) &&
           verifier.VerifyVectorOfStrings(metallic()) &&
           VerifyOffset(verifier, VT_OCCLUSION) &&
           verifier.VerifyVector(occlusion()) &&
           verifier.VerifyVectorOfStrings(occlusion()) &&
           VerifyOffset(verifier, VT_ROUGHNESS) &&
           verifier.VerifyVector(roughness()) &&
           verifier.VerifyVectorOfStrings(roughness()) &&
           VerifyOffset(verifier, VT_HEIGHT) &&
           verifier.VerifyVector(height()) &&
           verifier.VerifyVectorOfStrings(height()) &&
           VerifyOffset(verifier, VT_ANISOTROPY) &&
           verifier.VerifyVector(anisotropy()) &&
           verifier.VerifyVectorOfStrings(anisotropy()) &&
           VerifyOffset(verifier, VT_DETAIL) &&
           verifier.VerifyVector(detail()) &&
           verifier.VerifyVectorOfStrings(detail()) &&
           VerifyField<uint64_t>(verifier, VT_PACKSIZE) &&
           VerifyField<uint64_t>(verifier, VT_TOTALNUMBEROFTEXTURES) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metaData()) &&
           verifier.EndTable();
  }
};

struct TexturePackBuilder {
  typedef TexturePack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packName(uint64_t packName) {
    fbb_.AddElement<uint64_t>(TexturePack::VT_PACKNAME, packName, 0);
  }
  void add_albedo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> albedo) {
    fbb_.AddOffset(TexturePack::VT_ALBEDO, albedo);
  }
  void add_normal(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> normal) {
    fbb_.AddOffset(TexturePack::VT_NORMAL, normal);
  }
  void add_emissive(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> emissive) {
    fbb_.AddOffset(TexturePack::VT_EMISSIVE, emissive);
  }
  void add_metallic(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> metallic) {
    fbb_.AddOffset(TexturePack::VT_METALLIC, metallic);
  }
  void add_occlusion(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> occlusion) {
    fbb_.AddOffset(TexturePack::VT_OCCLUSION, occlusion);
  }
  void add_roughness(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> roughness) {
    fbb_.AddOffset(TexturePack::VT_ROUGHNESS, roughness);
  }
  void add_height(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> height) {
    fbb_.AddOffset(TexturePack::VT_HEIGHT, height);
  }
  void add_anisotropy(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> anisotropy) {
    fbb_.AddOffset(TexturePack::VT_ANISOTROPY, anisotropy);
  }
  void add_detail(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> detail) {
    fbb_.AddOffset(TexturePack::VT_DETAIL, detail);
  }
  void add_packSize(uint64_t packSize) {
    fbb_.AddElement<uint64_t>(TexturePack::VT_PACKSIZE, packSize, 0);
  }
  void add_totalNumberOfTextures(uint64_t totalNumberOfTextures) {
    fbb_.AddElement<uint64_t>(TexturePack::VT_TOTALNUMBEROFTEXTURES, totalNumberOfTextures, 0);
  }
  void add_metaData(flatbuffers::Offset<flat::TexturePackMetaData> metaData) {
    fbb_.AddOffset(TexturePack::VT_METADATA, metaData);
  }
  explicit TexturePackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TexturePackBuilder &operator=(const TexturePackBuilder &);
  flatbuffers::Offset<TexturePack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TexturePack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TexturePack> CreateTexturePack(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> albedo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> normal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> emissive = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> metallic = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> occlusion = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> roughness = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> height = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> anisotropy = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> detail = 0,
    uint64_t packSize = 0,
    uint64_t totalNumberOfTextures = 0,
    flatbuffers::Offset<flat::TexturePackMetaData> metaData = 0) {
  TexturePackBuilder builder_(_fbb);
  builder_.add_totalNumberOfTextures(totalNumberOfTextures);
  builder_.add_packSize(packSize);
  builder_.add_packName(packName);
  builder_.add_metaData(metaData);
  builder_.add_detail(detail);
  builder_.add_anisotropy(anisotropy);
  builder_.add_height(height);
  builder_.add_roughness(roughness);
  builder_.add_occlusion(occlusion);
  builder_.add_metallic(metallic);
  builder_.add_emissive(emissive);
  builder_.add_normal(normal);
  builder_.add_albedo(albedo);
  return builder_.Finish();
}

inline flatbuffers::Offset<TexturePack> CreateTexturePackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packName = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *albedo = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *normal = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *emissive = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *metallic = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *occlusion = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *roughness = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *height = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *anisotropy = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *detail = nullptr,
    uint64_t packSize = 0,
    uint64_t totalNumberOfTextures = 0,
    flatbuffers::Offset<flat::TexturePackMetaData> metaData = 0) {
  auto albedo__ = albedo ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*albedo) : 0;
  auto normal__ = normal ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*normal) : 0;
  auto emissive__ = emissive ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*emissive) : 0;
  auto metallic__ = metallic ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*metallic) : 0;
  auto occlusion__ = occlusion ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*occlusion) : 0;
  auto roughness__ = roughness ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*roughness) : 0;
  auto height__ = height ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*height) : 0;
  auto anisotropy__ = anisotropy ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*anisotropy) : 0;
  auto detail__ = detail ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*detail) : 0;
  return flat::CreateTexturePack(
      _fbb,
      packName,
      albedo__,
      normal__,
      emissive__,
      metallic__,
      occlusion__,
      roughness__,
      height__,
      anisotropy__,
      detail__,
      packSize,
      totalNumberOfTextures,
      metaData);
}

struct TexturePacksManifest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TexturePacksManifestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTUREPACKS = 4,
    VT_TOTALNUMBEROFTEXTURES = 6,
    VT_TOTALTEXTURESIZE = 8,
    VT_MAXTEXTURESINAPACK = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>> *texturePacks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>> *>(VT_TEXTUREPACKS);
  }
  uint64_t totalNumberOfTextures() const {
    return GetField<uint64_t>(VT_TOTALNUMBEROFTEXTURES, 0);
  }
  uint64_t totalTextureSize() const {
    return GetField<uint64_t>(VT_TOTALTEXTURESIZE, 0);
  }
  uint64_t maxTexturesInAPack() const {
    return GetField<uint64_t>(VT_MAXTEXTURESINAPACK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTUREPACKS) &&
           verifier.VerifyVector(texturePacks()) &&
           verifier.VerifyVectorOfTables(texturePacks()) &&
           VerifyField<uint64_t>(verifier, VT_TOTALNUMBEROFTEXTURES) &&
           VerifyField<uint64_t>(verifier, VT_TOTALTEXTURESIZE) &&
           VerifyField<uint64_t>(verifier, VT_MAXTEXTURESINAPACK) &&
           verifier.EndTable();
  }
};

struct TexturePacksManifestBuilder {
  typedef TexturePacksManifest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texturePacks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>>> texturePacks) {
    fbb_.AddOffset(TexturePacksManifest::VT_TEXTUREPACKS, texturePacks);
  }
  void add_totalNumberOfTextures(uint64_t totalNumberOfTextures) {
    fbb_.AddElement<uint64_t>(TexturePacksManifest::VT_TOTALNUMBEROFTEXTURES, totalNumberOfTextures, 0);
  }
  void add_totalTextureSize(uint64_t totalTextureSize) {
    fbb_.AddElement<uint64_t>(TexturePacksManifest::VT_TOTALTEXTURESIZE, totalTextureSize, 0);
  }
  void add_maxTexturesInAPack(uint64_t maxTexturesInAPack) {
    fbb_.AddElement<uint64_t>(TexturePacksManifest::VT_MAXTEXTURESINAPACK, maxTexturesInAPack, 0);
  }
  explicit TexturePacksManifestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TexturePacksManifestBuilder &operator=(const TexturePacksManifestBuilder &);
  flatbuffers::Offset<TexturePacksManifest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TexturePacksManifest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TexturePacksManifest> CreateTexturePacksManifest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>>> texturePacks = 0,
    uint64_t totalNumberOfTextures = 0,
    uint64_t totalTextureSize = 0,
    uint64_t maxTexturesInAPack = 0) {
  TexturePacksManifestBuilder builder_(_fbb);
  builder_.add_maxTexturesInAPack(maxTexturesInAPack);
  builder_.add_totalTextureSize(totalTextureSize);
  builder_.add_totalNumberOfTextures(totalNumberOfTextures);
  builder_.add_texturePacks(texturePacks);
  return builder_.Finish();
}

inline flatbuffers::Offset<TexturePacksManifest> CreateTexturePacksManifestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::TexturePack>> *texturePacks = nullptr,
    uint64_t totalNumberOfTextures = 0,
    uint64_t totalTextureSize = 0,
    uint64_t maxTexturesInAPack = 0) {
  auto texturePacks__ = texturePacks ? _fbb.CreateVector<flatbuffers::Offset<flat::TexturePack>>(*texturePacks) : 0;
  return flat::CreateTexturePacksManifest(
      _fbb,
      texturePacks__,
      totalNumberOfTextures,
      totalTextureSize,
      maxTexturesInAPack);
}

inline const flat::TexturePacksManifest *GetTexturePacksManifest(const void *buf) {
  return flatbuffers::GetRoot<flat::TexturePacksManifest>(buf);
}

inline const flat::TexturePacksManifest *GetSizePrefixedTexturePacksManifest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::TexturePacksManifest>(buf);
}

inline const char *TexturePacksManifestIdentifier() {
  return "tman";
}

inline bool TexturePacksManifestBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, TexturePacksManifestIdentifier());
}

inline bool VerifyTexturePacksManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::TexturePacksManifest>(TexturePacksManifestIdentifier());
}

inline bool VerifySizePrefixedTexturePacksManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::TexturePacksManifest>(TexturePacksManifestIdentifier());
}

inline const char *TexturePacksManifestExtension() {
  return "tman";
}

inline void FinishTexturePacksManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::TexturePacksManifest> root) {
  fbb.Finish(root, TexturePacksManifestIdentifier());
}

inline void FinishSizePrefixedTexturePacksManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::TexturePacksManifest> root) {
  fbb.FinishSizePrefixed(root, TexturePacksManifestIdentifier());
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_TEXTUREPACKMANIFEST_FLAT_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTUREPACKMANIFEST_FLAT_H_
#define FLATBUFFERS_GENERATED_TEXTUREPACKMANIFEST_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace flat {

struct TexturePack;
struct TexturePackBuilder;

struct TexturePacksManifest;
struct TexturePacksManifestBuilder;

struct TexturePack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TexturePackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKNAME = 4,
    VT_ALBEDO = 6,
    VT_NORMAL = 8,
    VT_SPECULAR = 10,
    VT_EMISSIVE = 12,
    VT_METALIC = 14,
    VT_OCCLUSION = 16,
    VT_MICRO = 18,
    VT_HEIGHT = 20,
    VT_PACKSIZE = 22,
    VT_TOTALNUMBEROFTEXTURES = 24
  };
  uint64_t packName() const {
    return GetField<uint64_t>(VT_PACKNAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *albedo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ALBEDO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *normal() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NORMAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *specular() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SPECULAR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *emissive() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EMISSIVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *metalic() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_METALIC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *occlusion() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OCCLUSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *micro() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MICRO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *height() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEIGHT);
  }
  uint64_t packSize() const {
    return GetField<uint64_t>(VT_PACKSIZE, 0);
  }
  uint64_t totalNumberOfTextures() const {
    return GetField<uint64_t>(VT_TOTALNUMBEROFTEXTURES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PACKNAME) &&
           VerifyOffset(verifier, VT_ALBEDO) &&
           verifier.VerifyVector(albedo()) &&
           verifier.VerifyVectorOfStrings(albedo()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(normal()) &&
           verifier.VerifyVectorOfStrings(normal()) &&
           VerifyOffset(verifier, VT_SPECULAR) &&
           verifier.VerifyVector(specular()) &&
           verifier.VerifyVectorOfStrings(specular()) &&
           VerifyOffset(verifier, VT_EMISSIVE) &&
           verifier.VerifyVector(emissive()) &&
           verifier.VerifyVectorOfStrings(emissive()) &&
           VerifyOffset(verifier, VT_METALIC) &&
           verifier.VerifyVector(metalic()) &&
           verifier.VerifyVectorOfStrings(metalic()) &&
           VerifyOffset(verifier, VT_OCCLUSION) &&
           verifier.VerifyVector(occlusion()) &&
           verifier.VerifyVectorOfStrings(occlusion()) &&
           VerifyOffset(verifier, VT_MICRO) &&
           verifier.VerifyVector(micro()) &&
           verifier.VerifyVectorOfStrings(micro()) &&
           VerifyOffset(verifier, VT_HEIGHT) &&
           verifier.VerifyVector(height()) &&
           verifier.VerifyVectorOfStrings(height()) &&
           VerifyField<uint64_t>(verifier, VT_PACKSIZE) &&
           VerifyField<uint64_t>(verifier, VT_TOTALNUMBEROFTEXTURES) &&
           verifier.EndTable();
  }
};

struct TexturePackBuilder {
  typedef TexturePack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packName(uint64_t packName) {
    fbb_.AddElement<uint64_t>(TexturePack::VT_PACKNAME, packName, 0);
  }
  void add_albedo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> albedo) {
    fbb_.AddOffset(TexturePack::VT_ALBEDO, albedo);
  }
  void add_normal(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> normal) {
    fbb_.AddOffset(TexturePack::VT_NORMAL, normal);
  }
  void add_specular(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> specular) {
    fbb_.AddOffset(TexturePack::VT_SPECULAR, specular);
  }
  void add_emissive(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> emissive) {
    fbb_.AddOffset(TexturePack::VT_EMISSIVE, emissive);
  }
  void add_metalic(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> metalic) {
    fbb_.AddOffset(TexturePack::VT_METALIC, metalic);
  }
  void add_occlusion(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> occlusion) {
    fbb_.AddOffset(TexturePack::VT_OCCLUSION, occlusion);
  }
  void add_micro(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> micro) {
    fbb_.AddOffset(TexturePack::VT_MICRO, micro);
  }
  void add_height(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> height) {
    fbb_.AddOffset(TexturePack::VT_HEIGHT, height);
  }
  void add_packSize(uint64_t packSize) {
    fbb_.AddElement<uint64_t>(TexturePack::VT_PACKSIZE, packSize, 0);
  }
  void add_totalNumberOfTextures(uint64_t totalNumberOfTextures) {
    fbb_.AddElement<uint64_t>(TexturePack::VT_TOTALNUMBEROFTEXTURES, totalNumberOfTextures, 0);
  }
  explicit TexturePackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TexturePackBuilder &operator=(const TexturePackBuilder &);
  flatbuffers::Offset<TexturePack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TexturePack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TexturePack> CreateTexturePack(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> albedo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> normal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> specular = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> emissive = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> metalic = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> occlusion = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> micro = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> height = 0,
    uint64_t packSize = 0,
    uint64_t totalNumberOfTextures = 0) {
  TexturePackBuilder builder_(_fbb);
  builder_.add_totalNumberOfTextures(totalNumberOfTextures);
  builder_.add_packSize(packSize);
  builder_.add_packName(packName);
  builder_.add_height(height);
  builder_.add_micro(micro);
  builder_.add_occlusion(occlusion);
  builder_.add_metalic(metalic);
  builder_.add_emissive(emissive);
  builder_.add_specular(specular);
  builder_.add_normal(normal);
  builder_.add_albedo(albedo);
  return builder_.Finish();
}

inline flatbuffers::Offset<TexturePack> CreateTexturePackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t packName = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *albedo = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *normal = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *specular = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *emissive = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *metalic = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *occlusion = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *micro = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *height = nullptr,
    uint64_t packSize = 0,
    uint64_t totalNumberOfTextures = 0) {
  auto albedo__ = albedo ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*albedo) : 0;
  auto normal__ = normal ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*normal) : 0;
  auto specular__ = specular ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*specular) : 0;
  auto emissive__ = emissive ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*emissive) : 0;
  auto metalic__ = metalic ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*metalic) : 0;
  auto occlusion__ = occlusion ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*occlusion) : 0;
  auto micro__ = micro ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*micro) : 0;
  auto height__ = height ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*height) : 0;
  return flat::CreateTexturePack(
      _fbb,
      packName,
      albedo__,
      normal__,
      specular__,
      emissive__,
      metalic__,
      occlusion__,
      micro__,
      height__,
      packSize,
      totalNumberOfTextures);
}

struct TexturePacksManifest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TexturePacksManifestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTUREPACKS = 4,
    VT_TOTALNUMBEROFTEXTURES = 6,
    VT_TOTALTEXTURESIZE = 8,
    VT_MAXTEXTURESINAPACK = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>> *texturePacks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>> *>(VT_TEXTUREPACKS);
  }
  uint64_t totalNumberOfTextures() const {
    return GetField<uint64_t>(VT_TOTALNUMBEROFTEXTURES, 0);
  }
  uint64_t totalTextureSize() const {
    return GetField<uint64_t>(VT_TOTALTEXTURESIZE, 0);
  }
  uint64_t maxTexturesInAPack() const {
    return GetField<uint64_t>(VT_MAXTEXTURESINAPACK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTUREPACKS) &&
           verifier.VerifyVector(texturePacks()) &&
           verifier.VerifyVectorOfTables(texturePacks()) &&
           VerifyField<uint64_t>(verifier, VT_TOTALNUMBEROFTEXTURES) &&
           VerifyField<uint64_t>(verifier, VT_TOTALTEXTURESIZE) &&
           VerifyField<uint64_t>(verifier, VT_MAXTEXTURESINAPACK) &&
           verifier.EndTable();
  }
};

struct TexturePacksManifestBuilder {
  typedef TexturePacksManifest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_texturePacks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>>> texturePacks) {
    fbb_.AddOffset(TexturePacksManifest::VT_TEXTUREPACKS, texturePacks);
  }
  void add_totalNumberOfTextures(uint64_t totalNumberOfTextures) {
    fbb_.AddElement<uint64_t>(TexturePacksManifest::VT_TOTALNUMBEROFTEXTURES, totalNumberOfTextures, 0);
  }
  void add_totalTextureSize(uint64_t totalTextureSize) {
    fbb_.AddElement<uint64_t>(TexturePacksManifest::VT_TOTALTEXTURESIZE, totalTextureSize, 0);
  }
  void add_maxTexturesInAPack(uint64_t maxTexturesInAPack) {
    fbb_.AddElement<uint64_t>(TexturePacksManifest::VT_MAXTEXTURESINAPACK, maxTexturesInAPack, 0);
  }
  explicit TexturePacksManifestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TexturePacksManifestBuilder &operator=(const TexturePacksManifestBuilder &);
  flatbuffers::Offset<TexturePacksManifest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TexturePacksManifest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TexturePacksManifest> CreateTexturePacksManifest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::TexturePack>>> texturePacks = 0,
    uint64_t totalNumberOfTextures = 0,
    uint64_t totalTextureSize = 0,
    uint64_t maxTexturesInAPack = 0) {
  TexturePacksManifestBuilder builder_(_fbb);
  builder_.add_maxTexturesInAPack(maxTexturesInAPack);
  builder_.add_totalTextureSize(totalTextureSize);
  builder_.add_totalNumberOfTextures(totalNumberOfTextures);
  builder_.add_texturePacks(texturePacks);
  return builder_.Finish();
}

inline flatbuffers::Offset<TexturePacksManifest> CreateTexturePacksManifestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::TexturePack>> *texturePacks = nullptr,
    uint64_t totalNumberOfTextures = 0,
    uint64_t totalTextureSize = 0,
    uint64_t maxTexturesInAPack = 0) {
  auto texturePacks__ = texturePacks ? _fbb.CreateVector<flatbuffers::Offset<flat::TexturePack>>(*texturePacks) : 0;
  return flat::CreateTexturePacksManifest(
      _fbb,
      texturePacks__,
      totalNumberOfTextures,
      totalTextureSize,
      maxTexturesInAPack);
}

inline const flat::TexturePacksManifest *GetTexturePacksManifest(const void *buf) {
  return flatbuffers::GetRoot<flat::TexturePacksManifest>(buf);
}

inline const flat::TexturePacksManifest *GetSizePrefixedTexturePacksManifest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::TexturePacksManifest>(buf);
}

inline const char *TexturePacksManifestIdentifier() {
  return "tman";
}

inline bool TexturePacksManifestBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, TexturePacksManifestIdentifier());
}

inline bool VerifyTexturePacksManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::TexturePacksManifest>(TexturePacksManifestIdentifier());
}

inline bool VerifySizePrefixedTexturePacksManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::TexturePacksManifest>(TexturePacksManifestIdentifier());
}

inline const char *TexturePacksManifestExtension() {
  return "tman";
}

inline void FinishTexturePacksManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::TexturePacksManifest> root) {
  fbb.Finish(root, TexturePacksManifestIdentifier());
}

inline void FinishSizePrefixedTexturePacksManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::TexturePacksManifest> root) {
  fbb.FinishSizePrefixed(root, TexturePacksManifestIdentifier());
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_TEXTUREPACKMANIFEST_FLAT_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ASSETMANIFEST_R2_H_
#define FLATBUFFERS_GENERATED_ASSETMANIFEST_R2_H_

#include "flatbuffers/flatbuffers.h"

namespace r2 {

struct AssetBuildCommand;
struct AssetBuildCommandBuilder;

struct AssetFileCommand;
struct AssetFileCommandBuilder;

struct AssetManifest;
struct AssetManifestBuilder;

enum AssetCompileCommand {
  AssetCompileCommand_NONE = 0,
  AssetCompileCommand_FLAT_BUFFER_COMPILE = 1,
  AssetCompileCommand_MIN = AssetCompileCommand_NONE,
  AssetCompileCommand_MAX = AssetCompileCommand_FLAT_BUFFER_COMPILE
};

inline const AssetCompileCommand (&EnumValuesAssetCompileCommand())[2] {
  static const AssetCompileCommand values[] = {
    AssetCompileCommand_NONE,
    AssetCompileCommand_FLAT_BUFFER_COMPILE
  };
  return values;
}

inline const char * const *EnumNamesAssetCompileCommand() {
  static const char * const names[3] = {
    "NONE",
    "FLAT_BUFFER_COMPILE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAssetCompileCommand(AssetCompileCommand e) {
  if (flatbuffers::IsOutRange(e, AssetCompileCommand_NONE, AssetCompileCommand_FLAT_BUFFER_COMPILE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAssetCompileCommand()[index];
}

enum AssetType {
  AssetType_RAW = 0,
  AssetType_ZIP = 1,
  AssetType_MIN = AssetType_RAW,
  AssetType_MAX = AssetType_ZIP
};

inline const AssetType (&EnumValuesAssetType())[2] {
  static const AssetType values[] = {
    AssetType_RAW,
    AssetType_ZIP
  };
  return values;
}

inline const char * const *EnumNamesAssetType() {
  static const char * const names[3] = {
    "RAW",
    "ZIP",
    nullptr
  };
  return names;
}

inline const char *EnumNameAssetType(AssetType e) {
  if (flatbuffers::IsOutRange(e, AssetType_RAW, AssetType_ZIP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAssetType()[index];
}

struct AssetBuildCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetBuildCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPILECOMMAND = 4,
    VT_SCHEMAPATH = 6
  };
  r2::AssetCompileCommand compileCommand() const {
    return static_cast<r2::AssetCompileCommand>(GetField<int8_t>(VT_COMPILECOMMAND, 0));
  }
  const flatbuffers::String *schemaPath() const {
    return GetPointer<const flatbuffers::String *>(VT_SCHEMAPATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMPILECOMMAND) &&
           VerifyOffset(verifier, VT_SCHEMAPATH) &&
           verifier.VerifyString(schemaPath()) &&
           verifier.EndTable();
  }
};

struct AssetBuildCommandBuilder {
  typedef AssetBuildCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_compileCommand(r2::AssetCompileCommand compileCommand) {
    fbb_.AddElement<int8_t>(AssetBuildCommand::VT_COMPILECOMMAND, static_cast<int8_t>(compileCommand), 0);
  }
  void add_schemaPath(flatbuffers::Offset<flatbuffers::String> schemaPath) {
    fbb_.AddOffset(AssetBuildCommand::VT_SCHEMAPATH, schemaPath);
  }
  explicit AssetBuildCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetBuildCommandBuilder &operator=(const AssetBuildCommandBuilder &);
  flatbuffers::Offset<AssetBuildCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetBuildCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetBuildCommand> CreateAssetBuildCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    r2::AssetCompileCommand compileCommand = r2::AssetCompileCommand_NONE,
    flatbuffers::Offset<flatbuffers::String> schemaPath = 0) {
  AssetBuildCommandBuilder builder_(_fbb);
  builder_.add_schemaPath(schemaPath);
  builder_.add_compileCommand(compileCommand);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetBuildCommand> CreateAssetBuildCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    r2::AssetCompileCommand compileCommand = r2::AssetCompileCommand_NONE,
    const char *schemaPath = nullptr) {
  auto schemaPath__ = schemaPath ? _fbb.CreateString(schemaPath) : 0;
  return r2::CreateAssetBuildCommand(
      _fbb,
      compileCommand,
      schemaPath__);
}

struct AssetFileCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetFileCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTFILE = 4,
    VT_OUTPUTFILE = 6,
    VT_BUILDCOMMAND = 8
  };
  const flatbuffers::String *inputFile() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUTFILE);
  }
  const flatbuffers::String *outputFile() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUTFILE);
  }
  const r2::AssetBuildCommand *buildCommand() const {
    return GetPointer<const r2::AssetBuildCommand *>(VT_BUILDCOMMAND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTFILE) &&
           verifier.VerifyString(inputFile()) &&
           VerifyOffset(verifier, VT_OUTPUTFILE) &&
           verifier.VerifyString(outputFile()) &&
           VerifyOffset(verifier, VT_BUILDCOMMAND) &&
           verifier.VerifyTable(buildCommand()) &&
           verifier.EndTable();
  }
};

struct AssetFileCommandBuilder {
  typedef AssetFileCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputFile(flatbuffers::Offset<flatbuffers::String> inputFile) {
    fbb_.AddOffset(AssetFileCommand::VT_INPUTFILE, inputFile);
  }
  void add_outputFile(flatbuffers::Offset<flatbuffers::String> outputFile) {
    fbb_.AddOffset(AssetFileCommand::VT_OUTPUTFILE, outputFile);
  }
  void add_buildCommand(flatbuffers::Offset<r2::AssetBuildCommand> buildCommand) {
    fbb_.AddOffset(AssetFileCommand::VT_BUILDCOMMAND, buildCommand);
  }
  explicit AssetFileCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetFileCommandBuilder &operator=(const AssetFileCommandBuilder &);
  flatbuffers::Offset<AssetFileCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetFileCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetFileCommand> CreateAssetFileCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> inputFile = 0,
    flatbuffers::Offset<flatbuffers::String> outputFile = 0,
    flatbuffers::Offset<r2::AssetBuildCommand> buildCommand = 0) {
  AssetFileCommandBuilder builder_(_fbb);
  builder_.add_buildCommand(buildCommand);
  builder_.add_outputFile(outputFile);
  builder_.add_inputFile(inputFile);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetFileCommand> CreateAssetFileCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *inputFile = nullptr,
    const char *outputFile = nullptr,
    flatbuffers::Offset<r2::AssetBuildCommand> buildCommand = 0) {
  auto inputFile__ = inputFile ? _fbb.CreateString(inputFile) : 0;
  auto outputFile__ = outputFile ? _fbb.CreateString(outputFile) : 0;
  return r2::CreateAssetFileCommand(
      _fbb,
      inputFile__,
      outputFile__,
      buildCommand);
}

struct AssetManifest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssetManifestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTPATH = 4,
    VT_INPUTFILES = 6,
    VT_OUTPUTTYPE = 8
  };
  const flatbuffers::String *outputPath() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUTPATH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<r2::AssetFileCommand>> *inputFiles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<r2::AssetFileCommand>> *>(VT_INPUTFILES);
  }
  r2::AssetType outputType() const {
    return static_cast<r2::AssetType>(GetField<int8_t>(VT_OUTPUTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUTPATH) &&
           verifier.VerifyString(outputPath()) &&
           VerifyOffset(verifier, VT_INPUTFILES) &&
           verifier.VerifyVector(inputFiles()) &&
           verifier.VerifyVectorOfTables(inputFiles()) &&
           VerifyField<int8_t>(verifier, VT_OUTPUTTYPE) &&
           verifier.EndTable();
  }
};

struct AssetManifestBuilder {
  typedef AssetManifest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputPath(flatbuffers::Offset<flatbuffers::String> outputPath) {
    fbb_.AddOffset(AssetManifest::VT_OUTPUTPATH, outputPath);
  }
  void add_inputFiles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<r2::AssetFileCommand>>> inputFiles) {
    fbb_.AddOffset(AssetManifest::VT_INPUTFILES, inputFiles);
  }
  void add_outputType(r2::AssetType outputType) {
    fbb_.AddElement<int8_t>(AssetManifest::VT_OUTPUTTYPE, static_cast<int8_t>(outputType), 0);
  }
  explicit AssetManifestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetManifestBuilder &operator=(const AssetManifestBuilder &);
  flatbuffers::Offset<AssetManifest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssetManifest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssetManifest> CreateAssetManifest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> outputPath = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<r2::AssetFileCommand>>> inputFiles = 0,
    r2::AssetType outputType = r2::AssetType_RAW) {
  AssetManifestBuilder builder_(_fbb);
  builder_.add_inputFiles(inputFiles);
  builder_.add_outputPath(outputPath);
  builder_.add_outputType(outputType);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetManifest> CreateAssetManifestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *outputPath = nullptr,
    const std::vector<flatbuffers::Offset<r2::AssetFileCommand>> *inputFiles = nullptr,
    r2::AssetType outputType = r2::AssetType_RAW) {
  auto outputPath__ = outputPath ? _fbb.CreateString(outputPath) : 0;
  auto inputFiles__ = inputFiles ? _fbb.CreateVector<flatbuffers::Offset<r2::AssetFileCommand>>(*inputFiles) : 0;
  return r2::CreateAssetManifest(
      _fbb,
      outputPath__,
      inputFiles__,
      outputType);
}

inline const r2::AssetManifest *GetAssetManifest(const void *buf) {
  return flatbuffers::GetRoot<r2::AssetManifest>(buf);
}

inline const r2::AssetManifest *GetSizePrefixedAssetManifest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<r2::AssetManifest>(buf);
}

inline const char *AssetManifestIdentifier() {
  return "aman";
}

inline bool AssetManifestBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, AssetManifestIdentifier());
}

inline bool VerifyAssetManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<r2::AssetManifest>(AssetManifestIdentifier());
}

inline bool VerifySizePrefixedAssetManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<r2::AssetManifest>(AssetManifestIdentifier());
}

inline const char *AssetManifestExtension() {
  return "aman";
}

inline void FinishAssetManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<r2::AssetManifest> root) {
  fbb.Finish(root, AssetManifestIdentifier());
}

inline void FinishSizePrefixedAssetManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<r2::AssetManifest> root) {
  fbb.FinishSizePrefixed(root, AssetManifestIdentifier());
}

}  // namespace r2

#endif  // FLATBUFFERS_GENERATED_ASSETMANIFEST_R2_H_

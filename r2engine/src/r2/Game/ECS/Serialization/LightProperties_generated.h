// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LIGHTPROPERTIES_FLAT_H_
#define FLATBUFFERS_GENERATED_LIGHTPROPERTIES_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace flat {

struct LightColor;

struct LightPosition;

struct ShadowInfo;

struct LightProperties;
struct LightPropertiesBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) LightColor FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  LightColor() {
    memset(static_cast<void *>(this), 0, sizeof(LightColor));
  }
  LightColor(float _r, float _g, float _b, float _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(LightColor, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) LightPosition FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  LightPosition() {
    memset(static_cast<void *>(this), 0, sizeof(LightPosition));
  }
  LightPosition(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(LightPosition, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ShadowInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t castsShadows_;
  uint32_t useSoftShadows_;

 public:
  ShadowInfo() {
    memset(static_cast<void *>(this), 0, sizeof(ShadowInfo));
  }
  ShadowInfo(uint32_t _castsShadows, uint32_t _useSoftShadows)
      : castsShadows_(flatbuffers::EndianScalar(_castsShadows)),
        useSoftShadows_(flatbuffers::EndianScalar(_useSoftShadows)) {
  }
  uint32_t castsShadows() const {
    return flatbuffers::EndianScalar(castsShadows_);
  }
  uint32_t useSoftShadows() const {
    return flatbuffers::EndianScalar(useSoftShadows_);
  }
};
FLATBUFFERS_STRUCT_END(ShadowInfo, 8);

struct LightProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LightPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIGHTCOLOR = 4,
    VT_SHADOWINFO = 6,
    VT_FALLOFF = 8,
    VT_INTENSITY = 10
  };
  const flat::LightColor *lightColor() const {
    return GetStruct<const flat::LightColor *>(VT_LIGHTCOLOR);
  }
  const flat::ShadowInfo *shadowInfo() const {
    return GetStruct<const flat::ShadowInfo *>(VT_SHADOWINFO);
  }
  float fallOff() const {
    return GetField<float>(VT_FALLOFF, 0.0f);
  }
  float intensity() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flat::LightColor>(verifier, VT_LIGHTCOLOR) &&
           VerifyField<flat::ShadowInfo>(verifier, VT_SHADOWINFO) &&
           VerifyField<float>(verifier, VT_FALLOFF) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           verifier.EndTable();
  }
};

struct LightPropertiesBuilder {
  typedef LightProperties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lightColor(const flat::LightColor *lightColor) {
    fbb_.AddStruct(LightProperties::VT_LIGHTCOLOR, lightColor);
  }
  void add_shadowInfo(const flat::ShadowInfo *shadowInfo) {
    fbb_.AddStruct(LightProperties::VT_SHADOWINFO, shadowInfo);
  }
  void add_fallOff(float fallOff) {
    fbb_.AddElement<float>(LightProperties::VT_FALLOFF, fallOff, 0.0f);
  }
  void add_intensity(float intensity) {
    fbb_.AddElement<float>(LightProperties::VT_INTENSITY, intensity, 0.0f);
  }
  explicit LightPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LightPropertiesBuilder &operator=(const LightPropertiesBuilder &);
  flatbuffers::Offset<LightProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LightProperties>(end);
    return o;
  }
};

inline flatbuffers::Offset<LightProperties> CreateLightProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    const flat::LightColor *lightColor = 0,
    const flat::ShadowInfo *shadowInfo = 0,
    float fallOff = 0.0f,
    float intensity = 0.0f) {
  LightPropertiesBuilder builder_(_fbb);
  builder_.add_intensity(intensity);
  builder_.add_fallOff(fallOff);
  builder_.add_shadowInfo(shadowInfo);
  builder_.add_lightColor(lightColor);
  return builder_.Finish();
}

inline const flat::LightProperties *GetLightProperties(const void *buf) {
  return flatbuffers::GetRoot<flat::LightProperties>(buf);
}

inline const flat::LightProperties *GetSizePrefixedLightProperties(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::LightProperties>(buf);
}

inline bool VerifyLightPropertiesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::LightProperties>(nullptr);
}

inline bool VerifySizePrefixedLightPropertiesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::LightProperties>(nullptr);
}

inline void FinishLightPropertiesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::LightProperties> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLightPropertiesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::LightProperties> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_LIGHTPROPERTIES_FLAT_H_

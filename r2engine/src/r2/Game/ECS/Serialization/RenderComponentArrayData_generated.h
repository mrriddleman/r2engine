// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RENDERCOMPONENTARRAYDATA_FLAT_H_
#define FLATBUFFERS_GENERATED_RENDERCOMPONENTARRAYDATA_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "AssetName_generated.h"

namespace flat {

struct StencilOp;
struct StencilOpBuilder;

struct StencilFunc;
struct StencilFuncBuilder;

struct StencilState;
struct StencilStateBuilder;

struct BlendFunc;
struct BlendFuncBuilder;

struct BlendState;
struct BlendStateBuilder;

struct CullState;
struct CullStateBuilder;

struct DrawParameters;
struct DrawParametersBuilder;

struct RenderComponentData;
struct RenderComponentDataBuilder;

struct RenderComponentArrayData;
struct RenderComponentArrayDataBuilder;

struct StencilOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StencilOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STENCILFAIL = 4,
    VT_DEPTHFAIL = 6,
    VT_DEPTHANDSTENCILPASS = 8
  };
  uint32_t stencilFail() const {
    return GetField<uint32_t>(VT_STENCILFAIL, 0);
  }
  uint32_t depthFail() const {
    return GetField<uint32_t>(VT_DEPTHFAIL, 0);
  }
  uint32_t depthAndStencilPass() const {
    return GetField<uint32_t>(VT_DEPTHANDSTENCILPASS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STENCILFAIL) &&
           VerifyField<uint32_t>(verifier, VT_DEPTHFAIL) &&
           VerifyField<uint32_t>(verifier, VT_DEPTHANDSTENCILPASS) &&
           verifier.EndTable();
  }
};

struct StencilOpBuilder {
  typedef StencilOp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stencilFail(uint32_t stencilFail) {
    fbb_.AddElement<uint32_t>(StencilOp::VT_STENCILFAIL, stencilFail, 0);
  }
  void add_depthFail(uint32_t depthFail) {
    fbb_.AddElement<uint32_t>(StencilOp::VT_DEPTHFAIL, depthFail, 0);
  }
  void add_depthAndStencilPass(uint32_t depthAndStencilPass) {
    fbb_.AddElement<uint32_t>(StencilOp::VT_DEPTHANDSTENCILPASS, depthAndStencilPass, 0);
  }
  explicit StencilOpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StencilOpBuilder &operator=(const StencilOpBuilder &);
  flatbuffers::Offset<StencilOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StencilOp>(end);
    return o;
  }
};

inline flatbuffers::Offset<StencilOp> CreateStencilOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t stencilFail = 0,
    uint32_t depthFail = 0,
    uint32_t depthAndStencilPass = 0) {
  StencilOpBuilder builder_(_fbb);
  builder_.add_depthAndStencilPass(depthAndStencilPass);
  builder_.add_depthFail(depthFail);
  builder_.add_stencilFail(stencilFail);
  return builder_.Finish();
}

struct StencilFunc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StencilFuncBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNC = 4,
    VT_REF = 6,
    VT_MASK = 8
  };
  uint32_t func() const {
    return GetField<uint32_t>(VT_FUNC, 0);
  }
  uint32_t ref() const {
    return GetField<uint32_t>(VT_REF, 0);
  }
  uint32_t mask() const {
    return GetField<uint32_t>(VT_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FUNC) &&
           VerifyField<uint32_t>(verifier, VT_REF) &&
           VerifyField<uint32_t>(verifier, VT_MASK) &&
           verifier.EndTable();
  }
};

struct StencilFuncBuilder {
  typedef StencilFunc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_func(uint32_t func) {
    fbb_.AddElement<uint32_t>(StencilFunc::VT_FUNC, func, 0);
  }
  void add_ref(uint32_t ref) {
    fbb_.AddElement<uint32_t>(StencilFunc::VT_REF, ref, 0);
  }
  void add_mask(uint32_t mask) {
    fbb_.AddElement<uint32_t>(StencilFunc::VT_MASK, mask, 0);
  }
  explicit StencilFuncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StencilFuncBuilder &operator=(const StencilFuncBuilder &);
  flatbuffers::Offset<StencilFunc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StencilFunc>(end);
    return o;
  }
};

inline flatbuffers::Offset<StencilFunc> CreateStencilFunc(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t func = 0,
    uint32_t ref = 0,
    uint32_t mask = 0) {
  StencilFuncBuilder builder_(_fbb);
  builder_.add_mask(mask);
  builder_.add_ref(ref);
  builder_.add_func(func);
  return builder_.Finish();
}

struct StencilState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StencilStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STENCILENABLED = 4,
    VT_STENCILWRITEENABLED = 6,
    VT_STENCILOP = 8,
    VT_STENCILFUNC = 10
  };
  bool stencilEnabled() const {
    return GetField<uint8_t>(VT_STENCILENABLED, 0) != 0;
  }
  bool stencilWriteEnabled() const {
    return GetField<uint8_t>(VT_STENCILWRITEENABLED, 0) != 0;
  }
  const flat::StencilOp *stencilOp() const {
    return GetPointer<const flat::StencilOp *>(VT_STENCILOP);
  }
  const flat::StencilFunc *stencilFunc() const {
    return GetPointer<const flat::StencilFunc *>(VT_STENCILFUNC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STENCILENABLED) &&
           VerifyField<uint8_t>(verifier, VT_STENCILWRITEENABLED) &&
           VerifyOffset(verifier, VT_STENCILOP) &&
           verifier.VerifyTable(stencilOp()) &&
           VerifyOffset(verifier, VT_STENCILFUNC) &&
           verifier.VerifyTable(stencilFunc()) &&
           verifier.EndTable();
  }
};

struct StencilStateBuilder {
  typedef StencilState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stencilEnabled(bool stencilEnabled) {
    fbb_.AddElement<uint8_t>(StencilState::VT_STENCILENABLED, static_cast<uint8_t>(stencilEnabled), 0);
  }
  void add_stencilWriteEnabled(bool stencilWriteEnabled) {
    fbb_.AddElement<uint8_t>(StencilState::VT_STENCILWRITEENABLED, static_cast<uint8_t>(stencilWriteEnabled), 0);
  }
  void add_stencilOp(flatbuffers::Offset<flat::StencilOp> stencilOp) {
    fbb_.AddOffset(StencilState::VT_STENCILOP, stencilOp);
  }
  void add_stencilFunc(flatbuffers::Offset<flat::StencilFunc> stencilFunc) {
    fbb_.AddOffset(StencilState::VT_STENCILFUNC, stencilFunc);
  }
  explicit StencilStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StencilStateBuilder &operator=(const StencilStateBuilder &);
  flatbuffers::Offset<StencilState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StencilState>(end);
    return o;
  }
};

inline flatbuffers::Offset<StencilState> CreateStencilState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool stencilEnabled = false,
    bool stencilWriteEnabled = false,
    flatbuffers::Offset<flat::StencilOp> stencilOp = 0,
    flatbuffers::Offset<flat::StencilFunc> stencilFunc = 0) {
  StencilStateBuilder builder_(_fbb);
  builder_.add_stencilFunc(stencilFunc);
  builder_.add_stencilOp(stencilOp);
  builder_.add_stencilWriteEnabled(stencilWriteEnabled);
  builder_.add_stencilEnabled(stencilEnabled);
  return builder_.Finish();
}

struct BlendFunc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlendFuncBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLENDDRAWBUFFER = 4,
    VT_SFACTOR = 6,
    VT_DFACTOR = 8
  };
  uint32_t blendDrawBuffer() const {
    return GetField<uint32_t>(VT_BLENDDRAWBUFFER, 0);
  }
  uint32_t sfactor() const {
    return GetField<uint32_t>(VT_SFACTOR, 0);
  }
  uint32_t dfactor() const {
    return GetField<uint32_t>(VT_DFACTOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BLENDDRAWBUFFER) &&
           VerifyField<uint32_t>(verifier, VT_SFACTOR) &&
           VerifyField<uint32_t>(verifier, VT_DFACTOR) &&
           verifier.EndTable();
  }
};

struct BlendFuncBuilder {
  typedef BlendFunc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blendDrawBuffer(uint32_t blendDrawBuffer) {
    fbb_.AddElement<uint32_t>(BlendFunc::VT_BLENDDRAWBUFFER, blendDrawBuffer, 0);
  }
  void add_sfactor(uint32_t sfactor) {
    fbb_.AddElement<uint32_t>(BlendFunc::VT_SFACTOR, sfactor, 0);
  }
  void add_dfactor(uint32_t dfactor) {
    fbb_.AddElement<uint32_t>(BlendFunc::VT_DFACTOR, dfactor, 0);
  }
  explicit BlendFuncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlendFuncBuilder &operator=(const BlendFuncBuilder &);
  flatbuffers::Offset<BlendFunc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlendFunc>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlendFunc> CreateBlendFunc(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t blendDrawBuffer = 0,
    uint32_t sfactor = 0,
    uint32_t dfactor = 0) {
  BlendFuncBuilder builder_(_fbb);
  builder_.add_dfactor(dfactor);
  builder_.add_sfactor(sfactor);
  builder_.add_blendDrawBuffer(blendDrawBuffer);
  return builder_.Finish();
}

struct BlendState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlendStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLENDINGENABLED = 4,
    VT_BLENDEQUATION = 6,
    VT_BLENDFUNCTIONS = 8
  };
  bool blendingEnabled() const {
    return GetField<uint8_t>(VT_BLENDINGENABLED, 0) != 0;
  }
  uint32_t blendEquation() const {
    return GetField<uint32_t>(VT_BLENDEQUATION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::BlendFunc>> *blendFunctions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::BlendFunc>> *>(VT_BLENDFUNCTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BLENDINGENABLED) &&
           VerifyField<uint32_t>(verifier, VT_BLENDEQUATION) &&
           VerifyOffset(verifier, VT_BLENDFUNCTIONS) &&
           verifier.VerifyVector(blendFunctions()) &&
           verifier.VerifyVectorOfTables(blendFunctions()) &&
           verifier.EndTable();
  }
};

struct BlendStateBuilder {
  typedef BlendState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blendingEnabled(bool blendingEnabled) {
    fbb_.AddElement<uint8_t>(BlendState::VT_BLENDINGENABLED, static_cast<uint8_t>(blendingEnabled), 0);
  }
  void add_blendEquation(uint32_t blendEquation) {
    fbb_.AddElement<uint32_t>(BlendState::VT_BLENDEQUATION, blendEquation, 0);
  }
  void add_blendFunctions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::BlendFunc>>> blendFunctions) {
    fbb_.AddOffset(BlendState::VT_BLENDFUNCTIONS, blendFunctions);
  }
  explicit BlendStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlendStateBuilder &operator=(const BlendStateBuilder &);
  flatbuffers::Offset<BlendState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlendState>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlendState> CreateBlendState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool blendingEnabled = false,
    uint32_t blendEquation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::BlendFunc>>> blendFunctions = 0) {
  BlendStateBuilder builder_(_fbb);
  builder_.add_blendFunctions(blendFunctions);
  builder_.add_blendEquation(blendEquation);
  builder_.add_blendingEnabled(blendingEnabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlendState> CreateBlendStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool blendingEnabled = false,
    uint32_t blendEquation = 0,
    const std::vector<flatbuffers::Offset<flat::BlendFunc>> *blendFunctions = nullptr) {
  auto blendFunctions__ = blendFunctions ? _fbb.CreateVector<flatbuffers::Offset<flat::BlendFunc>>(*blendFunctions) : 0;
  return flat::CreateBlendState(
      _fbb,
      blendingEnabled,
      blendEquation,
      blendFunctions__);
}

struct CullState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CullStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CULLINGENABLED = 4,
    VT_CULLFACE = 6,
    VT_FRONTFACE = 8
  };
  bool cullingEnabled() const {
    return GetField<uint8_t>(VT_CULLINGENABLED, 0) != 0;
  }
  uint32_t cullFace() const {
    return GetField<uint32_t>(VT_CULLFACE, 0);
  }
  uint32_t frontFace() const {
    return GetField<uint32_t>(VT_FRONTFACE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CULLINGENABLED) &&
           VerifyField<uint32_t>(verifier, VT_CULLFACE) &&
           VerifyField<uint32_t>(verifier, VT_FRONTFACE) &&
           verifier.EndTable();
  }
};

struct CullStateBuilder {
  typedef CullState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cullingEnabled(bool cullingEnabled) {
    fbb_.AddElement<uint8_t>(CullState::VT_CULLINGENABLED, static_cast<uint8_t>(cullingEnabled), 0);
  }
  void add_cullFace(uint32_t cullFace) {
    fbb_.AddElement<uint32_t>(CullState::VT_CULLFACE, cullFace, 0);
  }
  void add_frontFace(uint32_t frontFace) {
    fbb_.AddElement<uint32_t>(CullState::VT_FRONTFACE, frontFace, 0);
  }
  explicit CullStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CullStateBuilder &operator=(const CullStateBuilder &);
  flatbuffers::Offset<CullState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CullState>(end);
    return o;
  }
};

inline flatbuffers::Offset<CullState> CreateCullState(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool cullingEnabled = false,
    uint32_t cullFace = 0,
    uint32_t frontFace = 0) {
  CullStateBuilder builder_(_fbb);
  builder_.add_frontFace(frontFace);
  builder_.add_cullFace(cullFace);
  builder_.add_cullingEnabled(cullingEnabled);
  return builder_.Finish();
}

struct DrawParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DrawParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER = 4,
    VT_FLAGS = 6,
    VT_STENCILSTATE = 8,
    VT_BLENDSTATE = 10,
    VT_CULLSTATE = 12
  };
  uint32_t layer() const {
    return GetField<uint32_t>(VT_LAYER, 0);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const flat::StencilState *stencilState() const {
    return GetPointer<const flat::StencilState *>(VT_STENCILSTATE);
  }
  const flat::BlendState *blendState() const {
    return GetPointer<const flat::BlendState *>(VT_BLENDSTATE);
  }
  const flat::CullState *cullState() const {
    return GetPointer<const flat::CullState *>(VT_CULLSTATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LAYER) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_STENCILSTATE) &&
           verifier.VerifyTable(stencilState()) &&
           VerifyOffset(verifier, VT_BLENDSTATE) &&
           verifier.VerifyTable(blendState()) &&
           VerifyOffset(verifier, VT_CULLSTATE) &&
           verifier.VerifyTable(cullState()) &&
           verifier.EndTable();
  }
};

struct DrawParametersBuilder {
  typedef DrawParameters Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layer(uint32_t layer) {
    fbb_.AddElement<uint32_t>(DrawParameters::VT_LAYER, layer, 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(DrawParameters::VT_FLAGS, flags, 0);
  }
  void add_stencilState(flatbuffers::Offset<flat::StencilState> stencilState) {
    fbb_.AddOffset(DrawParameters::VT_STENCILSTATE, stencilState);
  }
  void add_blendState(flatbuffers::Offset<flat::BlendState> blendState) {
    fbb_.AddOffset(DrawParameters::VT_BLENDSTATE, blendState);
  }
  void add_cullState(flatbuffers::Offset<flat::CullState> cullState) {
    fbb_.AddOffset(DrawParameters::VT_CULLSTATE, cullState);
  }
  explicit DrawParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawParametersBuilder &operator=(const DrawParametersBuilder &);
  flatbuffers::Offset<DrawParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawParameters> CreateDrawParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t layer = 0,
    uint32_t flags = 0,
    flatbuffers::Offset<flat::StencilState> stencilState = 0,
    flatbuffers::Offset<flat::BlendState> blendState = 0,
    flatbuffers::Offset<flat::CullState> cullState = 0) {
  DrawParametersBuilder builder_(_fbb);
  builder_.add_cullState(cullState);
  builder_.add_blendState(blendState);
  builder_.add_stencilState(stencilState);
  builder_.add_flags(flags);
  builder_.add_layer(layer);
  return builder_.Finish();
}

struct RenderComponentData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderComponentDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSETMODELHASH = 4,
    VT_PRIMITIVETYPE = 6,
    VT_ISANIMATED = 8,
    VT_DRAWPARAMS = 10,
    VT_OVERRIDEMATERIALS = 12
  };
  uint64_t assetModelHash() const {
    return GetField<uint64_t>(VT_ASSETMODELHASH, 0);
  }
  uint32_t primitiveType() const {
    return GetField<uint32_t>(VT_PRIMITIVETYPE, 0);
  }
  bool isAnimated() const {
    return GetField<uint8_t>(VT_ISANIMATED, 0) != 0;
  }
  const flat::DrawParameters *drawParams() const {
    return GetPointer<const flat::DrawParameters *>(VT_DRAWPARAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::MaterialName>> *overrideMaterials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::MaterialName>> *>(VT_OVERRIDEMATERIALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ASSETMODELHASH) &&
           VerifyField<uint32_t>(verifier, VT_PRIMITIVETYPE) &&
           VerifyField<uint8_t>(verifier, VT_ISANIMATED) &&
           VerifyOffset(verifier, VT_DRAWPARAMS) &&
           verifier.VerifyTable(drawParams()) &&
           VerifyOffset(verifier, VT_OVERRIDEMATERIALS) &&
           verifier.VerifyVector(overrideMaterials()) &&
           verifier.VerifyVectorOfTables(overrideMaterials()) &&
           verifier.EndTable();
  }
};

struct RenderComponentDataBuilder {
  typedef RenderComponentData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_assetModelHash(uint64_t assetModelHash) {
    fbb_.AddElement<uint64_t>(RenderComponentData::VT_ASSETMODELHASH, assetModelHash, 0);
  }
  void add_primitiveType(uint32_t primitiveType) {
    fbb_.AddElement<uint32_t>(RenderComponentData::VT_PRIMITIVETYPE, primitiveType, 0);
  }
  void add_isAnimated(bool isAnimated) {
    fbb_.AddElement<uint8_t>(RenderComponentData::VT_ISANIMATED, static_cast<uint8_t>(isAnimated), 0);
  }
  void add_drawParams(flatbuffers::Offset<flat::DrawParameters> drawParams) {
    fbb_.AddOffset(RenderComponentData::VT_DRAWPARAMS, drawParams);
  }
  void add_overrideMaterials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::MaterialName>>> overrideMaterials) {
    fbb_.AddOffset(RenderComponentData::VT_OVERRIDEMATERIALS, overrideMaterials);
  }
  explicit RenderComponentDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderComponentDataBuilder &operator=(const RenderComponentDataBuilder &);
  flatbuffers::Offset<RenderComponentData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderComponentData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderComponentData> CreateRenderComponentData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t assetModelHash = 0,
    uint32_t primitiveType = 0,
    bool isAnimated = false,
    flatbuffers::Offset<flat::DrawParameters> drawParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::MaterialName>>> overrideMaterials = 0) {
  RenderComponentDataBuilder builder_(_fbb);
  builder_.add_assetModelHash(assetModelHash);
  builder_.add_overrideMaterials(overrideMaterials);
  builder_.add_drawParams(drawParams);
  builder_.add_primitiveType(primitiveType);
  builder_.add_isAnimated(isAnimated);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderComponentData> CreateRenderComponentDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t assetModelHash = 0,
    uint32_t primitiveType = 0,
    bool isAnimated = false,
    flatbuffers::Offset<flat::DrawParameters> drawParams = 0,
    const std::vector<flatbuffers::Offset<flat::MaterialName>> *overrideMaterials = nullptr) {
  auto overrideMaterials__ = overrideMaterials ? _fbb.CreateVector<flatbuffers::Offset<flat::MaterialName>>(*overrideMaterials) : 0;
  return flat::CreateRenderComponentData(
      _fbb,
      assetModelHash,
      primitiveType,
      isAnimated,
      drawParams,
      overrideMaterials__);
}

struct RenderComponentArrayData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderComponentArrayDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RENDERCOMPONENTARRAY = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::RenderComponentData>> *renderComponentArray() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::RenderComponentData>> *>(VT_RENDERCOMPONENTARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RENDERCOMPONENTARRAY) &&
           verifier.VerifyVector(renderComponentArray()) &&
           verifier.VerifyVectorOfTables(renderComponentArray()) &&
           verifier.EndTable();
  }
};

struct RenderComponentArrayDataBuilder {
  typedef RenderComponentArrayData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_renderComponentArray(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::RenderComponentData>>> renderComponentArray) {
    fbb_.AddOffset(RenderComponentArrayData::VT_RENDERCOMPONENTARRAY, renderComponentArray);
  }
  explicit RenderComponentArrayDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderComponentArrayDataBuilder &operator=(const RenderComponentArrayDataBuilder &);
  flatbuffers::Offset<RenderComponentArrayData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderComponentArrayData>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderComponentArrayData> CreateRenderComponentArrayData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::RenderComponentData>>> renderComponentArray = 0) {
  RenderComponentArrayDataBuilder builder_(_fbb);
  builder_.add_renderComponentArray(renderComponentArray);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderComponentArrayData> CreateRenderComponentArrayDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::RenderComponentData>> *renderComponentArray = nullptr) {
  auto renderComponentArray__ = renderComponentArray ? _fbb.CreateVector<flatbuffers::Offset<flat::RenderComponentData>>(*renderComponentArray) : 0;
  return flat::CreateRenderComponentArrayData(
      _fbb,
      renderComponentArray__);
}

inline const flat::RenderComponentArrayData *GetRenderComponentArrayData(const void *buf) {
  return flatbuffers::GetRoot<flat::RenderComponentArrayData>(buf);
}

inline const flat::RenderComponentArrayData *GetSizePrefixedRenderComponentArrayData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::RenderComponentArrayData>(buf);
}

inline bool VerifyRenderComponentArrayDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::RenderComponentArrayData>(nullptr);
}

inline bool VerifySizePrefixedRenderComponentArrayDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::RenderComponentArrayData>(nullptr);
}

inline void FinishRenderComponentArrayDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RenderComponentArrayData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRenderComponentArrayDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::RenderComponentArrayData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_RENDERCOMPONENTARRAYDATA_FLAT_H_

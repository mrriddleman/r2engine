// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SOUNDDEFINITION_R2_H_
#define FLATBUFFERS_GENERATED_SOUNDDEFINITION_R2_H_

#include "flatbuffers/flatbuffers.h"

namespace r2 {

struct SoundDefinition;

struct SoundDefinitions;

struct SoundDefinition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOUNDNAME = 4,
    VT_DEFAULTVOLUME = 6,
    VT_MINDISTANCE = 8,
    VT_MAXDISTANCE = 10,
    VT_IS3D = 12,
    VT_LOOP = 14,
    VT_STREAM = 16,
    VT_LOADONREGISTER = 18
  };
  const flatbuffers::String *soundName() const {
    return GetPointer<const flatbuffers::String *>(VT_SOUNDNAME);
  }
  float defaultVolume() const {
    return GetField<float>(VT_DEFAULTVOLUME, 0.0f);
  }
  float minDistance() const {
    return GetField<float>(VT_MINDISTANCE, 0.0f);
  }
  float maxDistance() const {
    return GetField<float>(VT_MAXDISTANCE, 0.0f);
  }
  bool is3D() const {
    return GetField<uint8_t>(VT_IS3D, 0) != 0;
  }
  bool loop() const {
    return GetField<uint8_t>(VT_LOOP, 0) != 0;
  }
  bool stream() const {
    return GetField<uint8_t>(VT_STREAM, 0) != 0;
  }
  bool loadOnRegister() const {
    return GetField<uint8_t>(VT_LOADONREGISTER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOUNDNAME) &&
           verifier.VerifyString(soundName()) &&
           VerifyField<float>(verifier, VT_DEFAULTVOLUME) &&
           VerifyField<float>(verifier, VT_MINDISTANCE) &&
           VerifyField<float>(verifier, VT_MAXDISTANCE) &&
           VerifyField<uint8_t>(verifier, VT_IS3D) &&
           VerifyField<uint8_t>(verifier, VT_LOOP) &&
           VerifyField<uint8_t>(verifier, VT_STREAM) &&
           VerifyField<uint8_t>(verifier, VT_LOADONREGISTER) &&
           verifier.EndTable();
  }
};

struct SoundDefinitionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_soundName(flatbuffers::Offset<flatbuffers::String> soundName) {
    fbb_.AddOffset(SoundDefinition::VT_SOUNDNAME, soundName);
  }
  void add_defaultVolume(float defaultVolume) {
    fbb_.AddElement<float>(SoundDefinition::VT_DEFAULTVOLUME, defaultVolume, 0.0f);
  }
  void add_minDistance(float minDistance) {
    fbb_.AddElement<float>(SoundDefinition::VT_MINDISTANCE, minDistance, 0.0f);
  }
  void add_maxDistance(float maxDistance) {
    fbb_.AddElement<float>(SoundDefinition::VT_MAXDISTANCE, maxDistance, 0.0f);
  }
  void add_is3D(bool is3D) {
    fbb_.AddElement<uint8_t>(SoundDefinition::VT_IS3D, static_cast<uint8_t>(is3D), 0);
  }
  void add_loop(bool loop) {
    fbb_.AddElement<uint8_t>(SoundDefinition::VT_LOOP, static_cast<uint8_t>(loop), 0);
  }
  void add_stream(bool stream) {
    fbb_.AddElement<uint8_t>(SoundDefinition::VT_STREAM, static_cast<uint8_t>(stream), 0);
  }
  void add_loadOnRegister(bool loadOnRegister) {
    fbb_.AddElement<uint8_t>(SoundDefinition::VT_LOADONREGISTER, static_cast<uint8_t>(loadOnRegister), 0);
  }
  explicit SoundDefinitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoundDefinitionBuilder &operator=(const SoundDefinitionBuilder &);
  flatbuffers::Offset<SoundDefinition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoundDefinition>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoundDefinition> CreateSoundDefinition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> soundName = 0,
    float defaultVolume = 0.0f,
    float minDistance = 0.0f,
    float maxDistance = 0.0f,
    bool is3D = false,
    bool loop = false,
    bool stream = false,
    bool loadOnRegister = false) {
  SoundDefinitionBuilder builder_(_fbb);
  builder_.add_maxDistance(maxDistance);
  builder_.add_minDistance(minDistance);
  builder_.add_defaultVolume(defaultVolume);
  builder_.add_soundName(soundName);
  builder_.add_loadOnRegister(loadOnRegister);
  builder_.add_stream(stream);
  builder_.add_loop(loop);
  builder_.add_is3D(is3D);
  return builder_.Finish();
}

inline flatbuffers::Offset<SoundDefinition> CreateSoundDefinitionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *soundName = nullptr,
    float defaultVolume = 0.0f,
    float minDistance = 0.0f,
    float maxDistance = 0.0f,
    bool is3D = false,
    bool loop = false,
    bool stream = false,
    bool loadOnRegister = false) {
  return r2::CreateSoundDefinition(
      _fbb,
      soundName ? _fbb.CreateString(soundName) : 0,
      defaultVolume,
      minDistance,
      maxDistance,
      is3D,
      loop,
      stream,
      loadOnRegister);
}

struct SoundDefinitions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DEFINITIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SoundDefinition>> *definitions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SoundDefinition>> *>(VT_DEFINITIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEFINITIONS) &&
           verifier.VerifyVector(definitions()) &&
           verifier.VerifyVectorOfTables(definitions()) &&
           verifier.EndTable();
  }
};

struct SoundDefinitionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_definitions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SoundDefinition>>> definitions) {
    fbb_.AddOffset(SoundDefinitions::VT_DEFINITIONS, definitions);
  }
  explicit SoundDefinitionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoundDefinitionsBuilder &operator=(const SoundDefinitionsBuilder &);
  flatbuffers::Offset<SoundDefinitions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoundDefinitions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoundDefinitions> CreateSoundDefinitions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SoundDefinition>>> definitions = 0) {
  SoundDefinitionsBuilder builder_(_fbb);
  builder_.add_definitions(definitions);
  return builder_.Finish();
}

inline flatbuffers::Offset<SoundDefinitions> CreateSoundDefinitionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SoundDefinition>> *definitions = nullptr) {
  return r2::CreateSoundDefinitions(
      _fbb,
      definitions ? _fbb.CreateVector<flatbuffers::Offset<SoundDefinition>>(*definitions) : 0);
}

inline const r2::SoundDefinitions *GetSoundDefinitions(const void *buf) {
  return flatbuffers::GetRoot<r2::SoundDefinitions>(buf);
}

inline const r2::SoundDefinitions *GetSizePrefixedSoundDefinitions(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<r2::SoundDefinitions>(buf);
}

inline const char *SoundDefinitionsIdentifier() {
  return "sdef";
}

inline bool SoundDefinitionsBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SoundDefinitionsIdentifier());
}

inline bool VerifySoundDefinitionsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<r2::SoundDefinitions>(SoundDefinitionsIdentifier());
}

inline bool VerifySizePrefixedSoundDefinitionsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<r2::SoundDefinitions>(SoundDefinitionsIdentifier());
}

inline const char *SoundDefinitionsExtension() {
  return "sdef";
}

inline void FinishSoundDefinitionsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<r2::SoundDefinitions> root) {
  fbb.Finish(root, SoundDefinitionsIdentifier());
}

inline void FinishSizePrefixedSoundDefinitionsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<r2::SoundDefinitions> root) {
  fbb.FinishSizePrefixed(root, SoundDefinitionsIdentifier());
}

}  // namespace r2

#endif  // FLATBUFFERS_GENERATED_SOUNDDEFINITION_R2_H_
